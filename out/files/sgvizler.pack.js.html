<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>sgvizler.pack.js - Sgvizler</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://beta.data2000.no/misc/image/mr.sgvizler.png" title="Sgvizler"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.6.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/MyOwnNamespace.HelloWorld.html">MyOwnNamespace.HelloWorld</a></li>
                                <li><a href="../classes/sgvizler.html">sgvizler</a></li>
                                <li><a href="../classes/sgvizler.charts.html">sgvizler.charts</a></li>
                                <li><a href="../classes/sgvizler.charts.Chart.html">sgvizler.charts.Chart</a></li>
                                <li><a href="../classes/sgvizler.container.html">sgvizler.container</a></li>
                                <li><a href="../classes/sgvizler.core.html">sgvizler.core</a></li>
                                <li><a href="../classes/sgvizler.datatable.html">sgvizler.datatable</a></li>
                                <li><a href="../classes/sgvizler.datatables.html">sgvizler.datatables</a></li>
                                <li><a href="../classes/sgvizler.defaults.html">sgvizler.defaults</a></li>
                                <li><a href="../classes/sgvizler.form.html">sgvizler.form</a></li>
                                <li><a href="../classes/sgvizler.loader.html">sgvizler.loader</a></li>
                                <li><a href="../classes/sgvizler.logger.html">sgvizler.logger</a></li>
                                <li><a href="../classes/sgvizler.namespace.html">sgvizler.namespace</a></li>
                                <li><a href="../classes/sgvizler.parser.html">sgvizler.parser</a></li>
                                <li><a href="../classes/sgvizler.Query.html">sgvizler.Query</a></li>
                                <li><a href="../classes/sgvizler.registry.html">sgvizler.registry</a></li>
                                <li><a href="../classes/sgvizler.util.html">sgvizler.util</a></li>
                                <li><a href="../classes/sgvizler.visualization.D3ForceGraph.html">sgvizler.visualization.D3ForceGraph</a></li>
                                <li><a href="../classes/sgvizler.visualization.DefList.html">sgvizler.visualization.DefList</a></li>
                                <li><a href="../classes/sgvizler.visualization.DraculaGraph.html">sgvizler.visualization.DraculaGraph</a></li>
                                <li><a href="../classes/sgvizler.visualization.List.html">sgvizler.visualization.List</a></li>
                                <li><a href="../classes/sgvizler.visualization.Map.html">sgvizler.visualization.Map</a></li>
                                <li><a href="../classes/sgvizler.visualization.MapWKT.html">sgvizler.visualization.MapWKT</a></li>
                                <li><a href="../classes/sgvizler.visualization.Table.html">sgvizler.visualization.Table</a></li>
                                <li><a href="../classes/sgvizler.visualization.Table_pict.html">sgvizler.visualization.Table_pict</a></li>
                                <li><a href="../classes/sgvizler.visualization.Text.html">sgvizler.visualization.Text</a></li>
                                <li><a href="../classes/sgvizler.visualization.util.html">sgvizler.visualization.util</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: sgvizler.pack.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
// Sgvizler - https://dev.data2000.no/sgvizler/
// (c) 2011--2013 - Martin G. Skj√¶veland - MIT license

(function (window, undefined) { // trick: safekeep &#x27;undefined&#x27;, and minify.
    &quot;use strict&quot;;

    /*global window, jQuery */
    /*jslint todo: true */

    var document = window.document, // trick: minify.
        S = {}, // local scope sgvizler variable.

        // Used in end. (Odd names such that these variables are not
        // accidentally accessed by child modules.)
        globalGetSet,
        globalDefaultsQuery,
        globalDefaultsChart;


        //// OTHER SOURCE FILES ARE CONCATENATED IN BELOW
        //// ENDING WITH end.js.part

    /**
     * Holds central constants.
     * 
     * @class sgvizler.core
     */

    S.core = (function () {

        // global public constants
        var

            /**
             * The version number of this sgvizler.
             * @property {string} VERSION
             * @final
             * @public
             * @for sgvizler
             * @since 0.6.0
             **/
            VERSION = &quot;0.6.0&quot;,

            /**
             * sgvizler&#x27;s homepage.
             * @property {string} HOMEPAGE
             * @final
             * @public
             * @for sgvizler
             * @since 0.6.0
             **/
            HOMEPAGE = &quot;http://mgskjaeveland.github.io/sgvizler/&quot;,

            // global private constants
            LOGOIMAGE = &quot;http://beta.data2000.no/sgvizler/misc/image/mr.sgvizler.png&quot;,
            CHARTSCSS = &quot;http://mgskjaeveland.github.io/sgvizler/v/0.6/sgvizler.charts.css&quot;;

        return {
            VERSION: VERSION,
            HOMEPAGE: HOMEPAGE,
            LOGOIMAGE: LOGOIMAGE,
            CHARTSCSS: CHARTSCSS
        };
    }());

    /**
     * A helpful set of static utility functions: type checking
     * variables, generic get-setter, get-setting values in
     * hierarchial objects, array functions, DOM manipulation, and
     * inheritance.
     *
     * Dependencies:
     *
     *   - jQuery
     *
     * @class sgvizler.util
     * @static
     */
    S.util = (function () {

        /*global $ */

        var

            /**
             * Checks if &#x60;input&#x60; is a string.
             * @method isString
             * @protected
             * @param input
             * @return {boolean} True iff &#x60;input&#x60; is a string.
             * @since 0.6.0
             **/
            isString = function (input) {
                return typeof input === &#x27;string&#x27;;
            },

            /**
             * Checks if &#x60;input&#x60; is a number.
             * @method isNumber
             * @protected
             * @param input
             * @return {boolean} True iff &#x60;input&#x60; is a number.
             * @since 0.6.0
             **/
            isNumber = function (input) {
                return typeof input === &#x27;number&#x27;;
            },

            /**
             * Checks if &#x60;input&#x60; is a boolean.
             * @method isBoolean
             * @protected
             * @param input
             * @return {boolean} True iff &#x60;input&#x60; is a boolean.
             * @since 0.6.0
             **/
            isBoolean = function (input) {
                return typeof input === &#x27;boolean&#x27;;
            },

            /**
             * Checks if &#x60;input&#x60; is a primitive, i.e., either a string,
             * a number or a boolean.
             * @method isPrimitive
             * @protected
             * @param input
             * @return {boolean} True iff &#x60;input&#x60; is a string, a number or a boolean.
             * @since 0.6.0
             **/
            isPrimitive = function (input) {
                return isString(input) || isNumber(input) || isBoolean(input);
            },

            /**
             * Checks if &#x60;input&#x60; is a function.
             * @method isFunction
             * @protected
             * @param input
             * @requires jQuery
             * @return {boolean} True iff &#x60;input&#x60; is a function.
             * @since 0.6.0
             **/
            isFunction = $.isFunction,

            /**
             * Checks if &#x60;input&#x60; is an array.
             * @method isArray
             * @protected
             * @param input
             * @requires jQuery
             * @return {boolean} True iff &#x60;input&#x60; is an array.
             * @since 0.6.0
             **/
            isArray = $.isArray,

            /**
             * Checks if &#x60;input&#x60; is a URL.
             * @method isURL
             * @protected
             * @param input
             * @return {boolean} True iff &#x60;input&#x60; is a URL.
             * @since 0.6.0
             **/
            URLpattern = new RegExp(
                &#x27;^(https?:\\/\\/)?&#x27;                                       // protocol
                    + &#x27;((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|&#x27;  // domain name
                    + &#x27;((\\d{1,3}\\.){3}\\d{1,3}))&#x27;                       // OR ip (v4) address
                    + &#x27;(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*&#x27;                   // port and path
                    + &#x27;(\\?[;&amp;a-z\\d%_.~+=-]*)?&#x27;                          // query string
                    + &#x27;(\\#[-a-z\\d_]*)?$&#x27;,                                // fragment locator
                &#x27;i&#x27;
            ),

            isURL = function (input) {
                return URLpattern.test(input);
            },

            /**
             * Establish &quot;classical inheritance&quot; from Parent to
             * Child. Child is linked to the Parent&#x27;s prototype
             * through a new proxy object. This means the Child has a
             * prototype object of its own, and access to the Parent&#x27;s
             * prototype.
             *
             * Taken from book &quot;JavaScript Patterns&quot;.
             * @method inherit
             * @protected
             * @param {Object} Child
             * @param {Object} Parent
             * @since 0.6.0
             **/
            inherit = (function () {
                var Proxy = function () {};
                return function (Child, Parent) {
                    Proxy.prototype = Parent.prototype;
                    Child.prototype = new Proxy();
                    //Child.superobject = Parent.prototype;
                    Child.prototype.constructor = Child;
                };
            }()),


            /**
             * Generic set/get method. If &#x60;value&#x60; is defined, then the
             * attribute/property &#x60;attr&#x60; of &#x60;setObject&#x60; is set to
             * &#x60;value&#x60; and &#x60;returnObject&#x60; is returned. Otherwise, the
             * (value of) &#x60;attr&#x60; attribute/property is
             * returned. Useful for a casading pattern.
             * @method getset
             * @protected
             * @param {string} attr The name of the property to get/set.
             * @param {Object} [value] The value to set.
             * @param {Object} setObject The object for which the property shall be set/get.
             * @param {Object} returnObject The object to return if value is undefined.
             * @return {any} Either &#x60;returnObject&#x60; or &#x60;setObject[attr]&#x60;
             * @example
             *     getset(&#x27;age&#x27;, 55, person.myArray, person)
             *   sets &#x60;person.myArray.age = 55&#x60; and returns &#x60;person&#x60;.
             *
             *     getset(&#x27;age&#x27;, undefined, person.myArray, person)
             *   returns &#x60;person.myArray.age&#x60;.
             * @since 0.6.0
             **/
            getset = function (attr, value, setObject, returnObject) {
                if (value !== undefined) {
                    setObject[attr] = value;
                }
                return (value !== undefined) ? returnObject : setObject[attr];
            },

            /**
             * Checks if a string starts with (is the prefix of) an other string.
             * @method startsWith
             * @protected
             * @param {string} string
             * @param {string} prefix
             * @return {boolean} True iff &#x60;prefix&#x60; is the prefix of &#x60;string&#x60;.
             * @example
             *     startsWith(&quot;Hal&quot;, &quot;Hallo!&quot;);  // returns true
             *     startsWith(&quot;hal&quot;, &quot;Hallo!&quot;);  // returns false
             * @since 0.6.0
             **/
            startsWith = function (string, prefix) {
                return string.lastIndexOf(prefix, 0) === 0;
            },

            /**
             * Gets the object located at &#x60;path&#x60; from &#x60;object&#x60;. &#x60;path&#x60;
             * is given in dot notation.
             *
             * @method getObjectByPath
             * @protected
             * @param {string} path
             * @param {Object} [object=window]
             * @param {boolean} [create=false]
             * @return {Object} Returns the object/value located at
             * the &#x60;path&#x60; of &#x60;object&#x60;; otherwise, if &#x60;create&#x60; is true,
             * it is created.
             * @example
             *     getObjectByPath(&#x27;sgvizler.visualization.Table&#x27;, registry, true)
             *   returns the object located at
             *   &#x60;registry[&#x27;sgvizler&#x27;][&#x27;visualization&#x27;][&#x27;Table&#x27;]&#x60; if it
             *   exists; otherwise, since &#x60;&#x27;create&#x27; === true&#x60;, the path
             *   and (empty) object is created and returned.
             * @since 0.6.0
             **/
            getObjectByPath = function (path, object, create) {
                var i, len,
                    segments = path.split(&#x27;.&#x27;),
                    cursor = object || window; // window is the global scope.

                for (i = 0, len = segments.length; i &lt; len; i += 1) {
                    if (cursor !== undefined &amp;&amp;                   // cursor must be defined
                            cursor[segments[i]] === undefined &amp;&amp;
                            create) {                             // create new child element.
                        cursor[segments[i]] = {};
                    }
                    cursor = cursor &amp;&amp; cursor[segments[i]];     // if cursor is undefined, it remains undefined.
                }
                return cursor;
            },

            /**
             * Checks if a an array contains a given element.
             * @method isInArray
             * @protected
             * @param {any} item
             * @param {Array} array
             * @return {boolean} True iff &#x60;array&#x60; contains an element &#x60;item&#x60;.
             * @since 0.6.0
             **/
            isInArray = function (item, array) {
                return ($.inArray(item, array) !== -1);
            },

            /**
             * Removes duplicates from an array.
             * @method removeDuplicates
             * @protected
             * @param {Array} array
             * @return {Array} The input array with duplicates removed.
             * @example
             *     removeDuplicates([1, 1, 1, 2, 4, 3, 2]);  // returns [1, 2, 4, 3]
             * @since 0.6.0
             **/
            removeDuplicates = function (array) {
                var i, len,
                    unique = [];
                for (i = 0, len = array.length; i &lt; len; i += 1) {
                    if (!isInArray(array[i], unique)) {
                        unique.push(array[i]);
                    }
                }
                return unique;
            },

            /**
             * Converts &#x60;input&#x60; to an array. If &#x60;input&#x60; is undefined,
             * then an empty array is returned. If &#x60;input&#x60; is
             * primitive, then it is put in an (empty) array. If &#x60;input&#x60;
             * /is/ an array, then the &#x60;input&#x60; is simply returned.
             *
             * Useful for converting input to other methods to arrays.
             * @method toArray
             * @protected
             * @param {undefined|primitive|Array} input
             * @return {Array} An array representation of &#x60;input&#x60;.
             * @example
             *     toArray(undefined);       // returns []
             *     toArray(&#x27;myString&#x27;);      // returns [&#x27;myString&#x27;]
             *     toArray([1, 2, 3]);       // returns [1, 2, 3]
             *     toArray(function () {});  // throws TypeError
             * @since 0.6.0
             **/
            toArray = function (input) {
                var output;
                if (input === undefined) {
                    output = [];
                } else if (isPrimitive(input)) {
                    output = [input];
                } else if (isArray(input)) {
                    output = input;
                } else {
                    throw new TypeError();
                }
                return output;
            },

            /**
             * Creates an HTML element according to a custom made
             * &quot;array syntax&quot;. Used to make HTML DOM manipulation more
             * code compact.
             * @method createHTMLElement
             * @protected
             * @param {string} elementType The type of element to
             * create, e.g., &quot;div&quot; or &quot;h1&quot;.
             * @param {Object} [attributes] Object of
             * attribute--value&#x27;s to be added to the element.
             * @param {Array|primitive} [children] An array of
             * children to be added to the element; each element in
             * the &#x60;children&#x60; array is an array of three elements, one
             * for each parameter of this method. If this argument is
             * a primitive, then it is inserted as a text node.
             * @return {Object} Element (ready for insertion into DOM.)
             * @example
             *     createHTMLElement(&#x27;ul&#x27;, { &#x27;class&#x27;: &quot;myClass&quot;, &#x27;id&#x27;: &quot;myID&quot; }, [ [&#x27;li&#x27;, null, &quot;One&quot; ],
             *                                                                     [&#x27;li&#x27;, { &#x27;id&#x27;: &quot;ABC&quot; } , 2 ],
             *                                                                     [&#x27;li&#x27;, null, true] ] );
             *
             *   will create the HTML element:
             *
             *     &lt;ul id=&quot;myID&quot; class=&quot;myClass&quot;&gt;
             *       &lt;li&gt;One&lt;/li&gt;
             *       &lt;li id=&quot;ABC&quot;&gt;2&lt;/li&gt;
             *       &lt;li&gt;true&lt;/li&gt;
             *     &lt;/ul&gt;
             * @since 0.6.0
             **/
            createHTMLElement = function createHTMLElement(elementType, attributes, children) {
                var i, len,
                    element = $(document.createElement(elementType)),
                    attr,
                    childs = toArray(children), // [sic]
                    child;

                // Add attributes to element.
                for (attr in attributes) {
                    if (attributes.hasOwnProperty(attr)) {
                        element.attr(attr, attributes[attr]);
                    }
                }

                // Add children to element. String are &quot;simply&quot; added, else it
                // should be an array of arguments to (recursive) create() call.
                for (i = 0, len = childs.length; i &lt; len; i += 1) {
                    child = childs[i];
                    if (isPrimitive(child)) {
                        element.append(child);
                    } else if (isArray(child)) {
                        element.append(createHTMLElement.apply(undefined, child));
                    } else {
                        throw new TypeError();
                    }
                }
                return element;
            };

        return {
            isString: isString,
            isNumber: isNumber,
            isBoolean: isBoolean,
            isPrimitive: isPrimitive,
            isFunction: isFunction,
            isArray: isArray,
            isURL: isURL,

            startsWith: startsWith,

            isInArray: isInArray,
            toArray: toArray,
            removeDuplicates: removeDuplicates,

            getObjectByPath: getObjectByPath,

            getset: getset,
            inherit: inherit,

            createHTMLElement: createHTMLElement
        };
    }());

    /**
     * Static class for handling prefixes and namespaces. Use for
     * storing prefixes used in SPARQL queries and for formatting
     * result sets, i.e., replacing namespaces with prefixes, which
     * many chart functions automatically do.
     *
     * Already defined prefixes are &#x60;rdf&#x60;, &#x60;rdfs&#x60;, &#x60;owl&#x60; and &#x60;xsd&#x60;.
     *
     * Dependencies:
     *
     *   - sgvizler.util
     *
     * @class sgvizler.namespace
     * @static
     */
    S.namespace = (function () {

        // Module dependencies:
        var startsWith = S.util.startsWith,
            isString = S.util.isString,

            /**
             * Stores prefix--namespace pairs.
             * @property nss
             * @type Object
             * @private
             * @since 0.1
             **/
            nss = {
                &#x27;rdf&#x27; : &quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;,
                &#x27;rdfs&#x27;: &quot;http://www.w3.org/2000/01/rdf-schema#&quot;,
                &#x27;owl&#x27; : &quot;http://www.w3.org/2002/07/owl#&quot;,
                &#x27;xsd&#x27; : &quot;http://www.w3.org/2001/XMLSchema#&quot;
            },

            /**
             * @property baseURL
             * @type String
             * @private
             * @since 0.6.0
             **/
            baseURL = null;

        /////////////////////////////////////////////////////////
        // PUBLICs

        return {

            /**
             * Get a namespace.
             *
             * See also set.
             *
             * @method get
             * @protected
             * @param {string} prefix The prefix to get the namespace for.
             * @return {string} The namespace set for &#x27;prefix&#x27;;
             * undefined if &#x27;prefix&#x27; does not exist.
             * @example
             *     get(&#x27;xsd&#x27;);  // returns &quot;http://www.w3.org/2001/XMLSchema#&quot;
             * @since 0.6.0
             **/
            get: function (prefix) {
                return nss[prefix];
            },

            /**
             * Set a namespace.
             *
             * See also get.
             *
             * @method set
             * @protected
             * @param {string} prefix The prefix to set.
             * @param {string} namespace The namespace to set.
             * @example
             *     set(&#x27;foaf&#x27;, &quot;http://xmlns.com/foaf/0.1/&quot;);
             *   sets &#x60;&#x27;foaf&#x27;&#x60; as prefix for the FOAF namespace.
             * @since 0.6.0
             **/
            set: function (prefix, namespace) {
                nss[prefix] = namespace;
            },

            /**
             * Get Base URL value.
             *
             * See also setBaseURL.
             *
             * @method getBaseURL
             * @return {string} The base URL.
             * @protected
             * @since 0.6.0
             **/
            getBaseURL: function () {
                return baseURL;
            },
            /**
             * Set Base URL value.
             *
             * See also setBaseURL.
             *
             * @method getBaseURL
             * @param {string} url The base URL.
             * @protected
             * @since 0.6.0
             **/
            setBaseURL: function (url) {
                baseURL = url;
            },

            /**
             * Get all prefixes in SPARQL format.
             * @method prefixesSPARQL
             * @protected
             * @return {string} An SPARQL formatted prefix declaration
             * text block containing all set prefixes.
             * @since 0.1
             **/
            prefixesSPARQL: function () {
                var prefix,
                    prefixes = &quot;&quot;;
                for (prefix in nss) {
                    if (nss.hasOwnProperty(prefix)) {
                        prefixes += &quot;PREFIX &quot; + prefix + &quot;: &lt;&quot; + nss[prefix] + &quot;&gt;\n&quot;;
                    }
                }
                return prefixes;
            },

            /**
             * Replace a namespace with its prefix, for string which
             * starts with a namespace. Typically used for URLs of
             * resources.
             *
             * Leaves other strings untouched.
             *
             * See also unprefixify.
             *
             * @method prefixify
             * @protected
             * @param {string} url
             * @return {string}
             * @example
             *     prefixify(&quot;http://www.w3.org/2002/07/owl#Class&quot;);  // returns &quot;owl:Class&quot;
             *     prefixify(&quot;Hello World!&quot;);   // returns &quot;Hello World!&quot;
             * @since 0.3.3
             **/
            prefixify: function (url) {
                var prefix;
                if (isString(url)) {
                    for (prefix in nss) {
                        if (nss.hasOwnProperty(prefix) &amp;&amp;
                                startsWith(url, nss[prefix])) {
                            return url.replace(nss[prefix], prefix + &quot;:&quot;);
                        }
                    }
                }
                return url;
            },

            /**
             * Replace a prefix with its namespace, for string which
             * starts with a prefix: Typically used for prefixed URLs
             * (QNames) of resources.
             *
             * Leaves other strings untouched.
             *
             * See also prefixify.
             *
             * @method unprefixify
             * @protected
             * @param {string} qname
             * @return {string}
             * @example
             *     unprefixify(&quot;owl:Class&quot;);     // returns &quot;http://www.w3.org/2002/07/owl#Class&quot;
             *     unprefixify(&quot;Hello World!&quot;);  // returns &quot;Hello World!&quot;
             * @since 0.3.3
             **/
            unprefixify: function (qname) {
                var prefix;
                if (isString(qname)) {
                    for (prefix in nss) {
                        if (nss.hasOwnProperty(prefix) &amp;&amp;
                                startsWith(qname, prefix + &quot;:&quot;)) {
                            return qname.replace(prefix + &quot;:&quot;, nss[prefix]);
                        }
                    }
                }
                return qname;
            }
        };

    }());

    //TODO publish libs at libFolder

    /**
     * Static class for handling functions used for drawing charts,
     * mainpulating datacharts, and what their dependencies are.
     * 
     * Dependencies:
     * 
     *  - sgvizler.util
     * 
     * See also:
     * 
     *   - sgvizler.charts, sgvizler.datatables (classes for creating new such functions)
     *   - sgvizler.loader (class for loading dependencies)
     * 
     * @class sgvizler.registry
     * @static
     */
    S.registry = (function () {

        // Module dependencies:
        var util = S.util,

            /**
             * The Google Visualization package name.
             * @property GVIZ
             * @type String
             * @private
             * @final 
             * @since 0.6.0
             **/
            GVIZ = &#x27;google.visualization&#x27;,

            /**
             * The Google Visualization DataTable class name.
             * @property DATATABLE
             * @type String
             * @private
             * @final 
             * @since 0.6.0
             **/
            DATATABLE = GVIZ + &#x27;.DataTable&#x27;,

            /**
             * The Google Maps package name.
             * @property GVIZ
             * @type String
             * @private
             * @final 
             * @since 0.6.0
             **/
            GMAP = &#x27;google.maps&#x27;,

            /**
             * Stores the modules of the registered functions
             * according to the type of function, i.e., &#x60;chart&#x60; or
             * &#x60;datatable&#x60;.
             * @property modules
             * @type Object
             * @private
             * @since 0.6.0
             **/
            modules = {
                chart: [GVIZ],//, GMAP],
                datatable: []
            },

            /**
             * Stores registered function names and their
             * dependencies, e.g., specifies which google
             * visualization packages to load for the different
             * charts.
             * 
             * Property legend:
             * 
             *  - &#x60;t&#x60;: type. Values: &#x60;core&#x60;, &#x60;datatable&#x60;, &#x60;chart&#x60; (default)
             *  - &#x60;d&#x60;: dependences. Object containing functions--gviz package/js file
             *    - &#x60;i&#x60;: the function itself, as in I.
             * 
             * @property registry
             * @type Object
             * @private
             * @since 0.6.0
             **/
            registry = {
                google: {
                    //////////////////////////////////////////////////////
                    // google.visualization
                    visualization: {
                        DataTable: {
                            t: &#x27;core&#x27;,
                            d: { i: GVIZ }
                        },
                        LineChart: {
                            d: { i: &#x27;corechart&#x27; }
                        },
                        AreaChart: {
                            d: { i: &#x27;corechart&#x27; }
                        },
                        SteppedAreaChart: {
                            d: { i: &#x27;corechart&#x27; }
                        },
                        PieChart: {
                            d: { i: &#x27;corechart&#x27; }
                        },
                        BubbleChart: {
                            d: { i: &#x27;corechart&#x27; }
                        },
                        ColumnChart: {
                            d: { i: &#x27;corechart&#x27; }
                        },
                        BarChart: {
                            d: { i: &#x27;corechart&#x27; }
                        },
                        ImageSparkLine: {
                            d: { i: &#x27;imagesparkline&#x27; }
                        },
                        ScatterChart: {
                            d: { i: &#x27;corechart&#x27; }
                        },
                        CandlestickChart: {
                            d: { i: &#x27;corechart&#x27; }
                        },
                        Gauge: {
                            d: { i: &#x27;gauge&#x27; }
                        },
                        OrgChart: {
                            d: { i: &#x27;orgchart&#x27; }
                        },
                        TreeMap: {
                            d: { i: &#x27;treemap&#x27; }
                        },
                        AnnotatedTimeLine: {
                            d: { i: &#x27;annotatedtimeline&#x27; }
                        },
                        MotionChart: {
                            d: { i: &#x27;motionchart&#x27; }
                        },
                        GeoChart: {
                            d: { i: &#x27;geochart&#x27; }
                        },
                        GeoMap: {
                            d: { i: &#x27;geomap&#x27; }
                        },
                        Map: {
                            d: { i: &#x27;map&#x27; }
                        },
                        Table: {
                            d: { i: &#x27;table&#x27; }
                        }
                    },
                    //////////////////////////////////////////////////////
                    // google.maps
                    maps: {
                        Map: {
                            d: { i: &#x27;map&#x27; }
                        }
                    }
                }
            };

        ////////////////////////////////////////////
        // PUBLICs

        return {

            // Constants
            GVIZ: GVIZ,
            GMAP: GMAP,
            DATATABLE: DATATABLE,

            /**
             * Get list of registered chart module (names), i.e., modules for
             * which there are registered functions for drawing
             * charts.
             * @method chartModules
             * @protected
             * @return {Array} (an array of strings)
             * @since 0.6.0
             **/
            chartModules: function () {
                return modules.chart;
            },

            /**
             * Get list of registered chart functions names (not the
             * functions themselves).
             * @method chartsFunctions
             * @protected
             * @return {Array} (an array of strings)
             * @since 0.6.0
             **/
            chartFunctions: function () {
                var i, len,
                    libs = modules.chart,//TODO: should be chartModules() but gives &quot;is not defined&quot;-error.
                    lib,
                    func,
                    charts = [];

                for (i = 0, len = libs.length; i &lt; len; i += 1) {
                    lib = util.getObjectByPath(libs[i], registry);
                    for (func in lib) {
                        if (lib.hasOwnProperty(func) &amp;&amp;
                                (lib[func].t === undefined ||
                                 lib[func].t === &#x27;chart&#x27;)) {
                            charts.push(libs[i] + &quot;.&quot; + func);
                        }
                    }
                }
                return charts;
            },

            /**
             * Get list of dependencies, either google visualization
             * packages or javascripts (URLs), for given function
             * name.
             * @method getDependencies
             * @protected
             * @param {String} functionName
             * @return {Array} (an array of strings)
             * @since 0.6.0
             **/
            getDependencies: function (functionName) {
                var regFunc = util.getObjectByPath(functionName, registry),
                    deps = (regFunc &amp;&amp; regFunc.d) || {};

                // rename i to functionName:
                if (deps.i) {
                    deps[functionName] = deps.i;
                    delete deps.i;
                }
                return deps;
            },

            /**
             * Add function to registry.
             * @method addFunction
             * @protected
             * @param {String} module name of module to which function belongs.
             * @param {String} name name of function.
             * @param {String} type of function, usually either &#x60;&#x27;chart&#x27;&#x60;, &#x60;&#x27;datatable&#x27;&#x60;.
             * @param {Object} dependencies list of function
             * name--dependency pairs. Example: &#x60;{ &#x27;XYZ&#x27;:
             * &#x27;http://example.org/XYZ.js&#x27; }&#x60; if the function requires
             * the XYX function to draw and this function is located
             * at &#x60;http://example.org/XYZ.js&#x60;.
             * @since 0.6.0
             **/
            addFunction: function (module, name, type, dependencies) {
                var regFunc; // The function&#x27;s place in registry.

                // Add module if it is new.
                if (!util.isInArray(module, modules[type])) {
                    modules[type].push(module);
                }

                // Add function to registry.
                regFunc = util.getObjectByPath(module + &quot;.&quot; + name, registry, true);

                if (type) {
                    regFunc.t = type;
                }
                if (dependencies) {
                    regFunc.d = dependencies;
                }
            }

        };
    }());
    /**
     * Handles all logging, either to console or designated HTML
     * container.
     *
     * Needs more work.
     *
     * @class sgvizler.logger
     * @static
     */
    S.logger = (function () {

        /*global $, console*/

        // Module dependencies:
        //var util = S.util,
        var
            /**
             * The timestamp for the load start of the current running
             * version of sgvizler. Used to calculate time elapse of
             * future events.
             * @property start
             * @type number
             * @private
             * @since 0.6.0
             **/
            startTime = Date.now(),

            /**
             * @method timeElapsed
             * @private
             * @return {number} The number of seconds elapsed since
             * this sgvizler got loaded.
             * @since 0.6.0
             **/
            elapsedTime = function () {
                return (Date.now() - startTime) / 1000;
            },

            /**
             * @property waitingCharts
             * @type number
             * @private
             * @beta
             **/
            waitingCharts = 0;

        return {

            /**
             * Logs a message.
             * @method log
             * @protected
             * @param {string} message The message to log.
             * @beta
             */
            log: function (message) {
                console.log(elapsedTime() + &quot;s: &quot; + message);
            },

            // TODO
            loadingChart: function () {
                waitingCharts += 1;
                if (!$(&#x27;body,html&#x27;).css(&#x27;cursor&#x27;, &#x27;progress&#x27;)) {
                    $(&#x27;body,html&#x27;).css(&#x27;cursor&#x27;, &#x27;progress&#x27;);
                }
            },
            doneLoadingChart: function () {
                waitingCharts -= 1;
                if (waitingCharts === 0 &amp;&amp; $(&#x27;body,html&#x27;).css(&#x27;cursor&#x27;, &#x27;progress&#x27;)) {
                    $(&#x27;body,html&#x27;).css(&#x27;cursor&#x27;, &#x27;default&#x27;);
                }
            }

            // TODO
        //     displayFeedback: function (query, messageName) {
        //         var message,
        //             container = query.logContainer();

        //         if (query.loglevel() === 0) {
        //             message = &quot;&quot;;
        //         } else if (query.loglevel() === 1) {
        //             if (messageName === &quot;LOADING&quot;) {
        //                 message = &quot;Loading...&quot;;
        //             } else if (messageName === &quot;ERROR_ENDPOINT&quot; || messageName === &quot;ERROR_UNKNOWN&quot;) {
        //                 message = &quot;Error.&quot;;
        //             }
        //         } else {
        //             if (messageName === &quot;LOADING&quot;) {
        //                 message = &quot;Sending query ...&quot;;
        //             } else if (messageName === &quot;ERROR_ENDPOINT&quot;) {
        //                 message = &quot;Error querying endpoint. Possible errors:&quot; +
        //                     util.html.ul(
        //                         util.html.a(query.endpoint(), &quot;SPARQL endpoint&quot;) + &quot; down? &quot; +
        //                             util.html.a(query.endpoint() + query.endpointQueryURL + query.encodedQuery(),
        //                                         &quot;Check if query runs at the endpoint&quot;) + &quot;.&quot;,
        //                         &quot;Malformed SPARQL query? &quot; +
        //                             util.html.a(query.validatorQueryURL() + query.encodedQuery(), &quot;Check if it validates&quot;) + &quot;.&quot;,
        //                         &quot;CORS supported and enabled? Read more about &quot; +
        //                             util.html.a(S.homepage + &quot;/wiki/Compatibility&quot;, &quot;CORS and compatibility&quot;) + &quot;.&quot;,
        //                         &quot;Is your &quot; + util.html.a(S.homepage + &quot;/wiki/Compatibility&quot;, &quot;browser support&quot;) + &quot;ed?&quot;,
        //                         &quot;Hmm.. it might be a bug! Please file a report to &quot; +
        //                             util.html.a(S.homepage + &quot;/issues/&quot;, &quot;the issues&quot;) + &quot;.&quot;
        //                     );
        //             } else if (messageName === &quot;ERROR_UNKNOWN&quot;) {
        //                 message = &quot;Unknown error.&quot;;
        //             } else if (messageName === &quot;NO_RESULTS&quot;) {
        //                 message = &quot;Query returned no results.&quot;;
        //             } else if (messageName === &quot;DRAWING&quot;) {
        //                 message = &quot;Received &quot; + query.noRows + &quot; rows. Drawing chart...&lt;br/&gt;&quot; +
        //                     util.html.a(query.endpoint + query.endpoint_query_url + query.encodedQuery,
        //                                 &quot;View query results&quot;, &quot;target=&#x27;_blank&#x27;&quot;) + &quot; (in new window).&quot;;
        //             }
        //         }
        //         if (message) {
        //             $(&#x27;#&#x27; + container).append(util.html.tag(&quot;p&quot;, message));
        //         }
        //     }
        };
    }());

    /**
     * Factory for creating new chart types. Ensures that chart types
     * correctly inherit methods from the inner class Chart.
     *
     * Dependencies:
     *
     *  - sgvizler.util
     *  - sgvizler.registry
     *
     * 
     * 
     * @class sgvizler.charts
     * @static
     */
    S.charts = (function () {

        var
            // Module dependencies:
            inherit = S.util.inherit,
            addFunction = S.registry.addFunction,

            Chart, // parent chart class. Created below so that
                   // documentation of methods falls into the right
                   // class.

            /**
             * Create new Chart type.
             * @method chartsAdd
             * @public
             * @for sgvizler
             * @param {String} module The module/namespace name to
             * which the function belongs.
             * @param {String} name The name of the function.
             * @param {Function} draw The function which will be the
             * &#x60;draw()&#x60; function of the new chart type.
             * @param {Object} dependencies The list of dependencies
             * for the chart type: function name -- google
             * package/javascript URL pairs.
             * @return {Object} The chart type.
             * @since 0.6.0
             **/
            add = function (module, name, draw, dependencies) {
                // This is the object from which new are created.
                var NewChart = function (container) {
                    Chart.call(this, container);
                };

                // Set inheritance.
                inherit(NewChart, Chart);

                // Copy draw() into new object.
                NewChart.prototype.draw = draw;

                addFunction(module, name, &#x27;chart&#x27;, dependencies);
                return NewChart;
            };


        /////////////////////////////////////////////////////////
        // Inner class Chart

        /**
         * Inner class which all chart types created by
         * sgvizler.charts inherit from, i.e., don&#x27;t create new charts
         * from this class, but use sgvizler.charts.create() instead.
         * @class sgvizler.charts.Chart
         * @constructor
         * @param {Object} container The container element where the
         * chart will be drawn.
         */
        // This function builds the class Chart.
        Chart = (function () {
            var C = function (container) {
                this.container = container;
                this.listeners = {};
            };
            C.prototype = {

                /**
                 * Add a function which is to be fired when the
                 * listener named &#x60;name&#x60; is fired.
                 *
                 * See &#x60;fireListener&#x60;
                 *
                 * @method addListener
                 * @public
                 * @param {String} name The name of the listener.
                 * @param {Function} func The function to fire.
                 * @example
                 *     addListener(&quot;ready&quot;, function () { console.log(&quot;Ready!&quot;) });
                 * @since 0.6.0
                 **/
                addListener: function (name, func) {
                    if (typeof func === &#x27;function&#x27;) { // accept only functions.
                        this.listeners[name] = this.listeners[name] || [];
                        this.listeners[name].push(func);
                    } else {
                        throw new TypeError();
                    }
                },

                /**
                 * Fires (runs, executes) all functions registered
                 * on the listener &#x60;name&#x60;.
                 *
                 * See &#x60;addListener&#x60;.
                 *
                 * @method fireListener
                 * @public
                 * @param {String} name The name of the listener.
                 * @since 0.6.0
                 **/
                fireListener: function (name) {
                    if (this.listeners[name]) {
                        while (this.listeners[name].length) {
                            (this.listeners[name].pop())(); // run function.
                        }
                    }
                }
            };
            return C;
        }());

        /////////////////////////////////////////////////////////
        // PUBLICs for sgvizler.charts
        return {
            add: add
        };
    }());

    /**
     * Factory for creating new datatypes functions.
     * 
     * Dependencies:
     * 
     *  - sgvizler.registry
     * 
     * @class sgvizler.datatables
     * @static
     */
    S.datatables = (function () {

        // Module dependencies:
        var addFunction = S.registry.addFunction,

            /**
             * Create new Chart type.
             * @method datatablesAdd
             * @public
             * @for sgvizler
             * @param {String} module The module/namespace name to
             * which the function belongs.
             * @param {String} name The name of the function.
             * @param {Function} func The datatable processing function.
             * @param {Object} dependencies The list of dependencies
             * for the chart type: function name -- google
             * package/javascript URL pairs.
             * @return {Function} The datatable processing function.
             * @since 0.6.0
             */
            add = function (module, name, func, dependencies) {
                addFunction(module, name, &#x27;datatable&#x27;, dependencies);
                return func;
            };

        /////////////////////////////////////////////////////////
        // PUBLICs chartFactory

        return {
            add: add
        };
    }());


    /** 
     * Parses a SPARQL result set, assumed to be in either W3C&#x27;s
     * [XML](http://www.w3.org/TR/rdf-sparql-XMLres/) or
     * [JSON](http://www.w3.org/TR/rdf-sparql-json-res/) format, into
     * [Google
     * JSON](https://developers.google.com/chart/interactive/docs/reference#DataTable)
     * which is the JSON format that the
     * &#x60;google.visualization.DataTable&#x60; class accepts.
     * 
     * Variable notation: xtable, xcol(s), xrow(s) -- x is &#x27;s&#x27;(parql)
     * or &#x27;g&#x27;(oogle).
     * 
     * Dependencies:
     *   - &#x60;sgvizler.namespace&#x60;
     *   - jQuery - for xml &quot;browsing&quot;.
     * 
     * @class sgvizler.parser
     * @static
     */

    S.parser = (function () {

        /*global $ */

        // Module dependencies:
        var namespace = S.namespace,

            /**
             * Convertion table for turning XSD datatypes into the
             * &quot;javascript&quot; datatypes which the
             * &#x60;google.visualization.DataTable&#x60; accepts, which is: &#x60;string&#x60;,
             * &#x60;number&#x60;, &#x60;boolean&#x60;, &#x60;date&#x60;, &#x60;datetime&#x60;, &#x60;timeofday&#x60;.
             * @property datatypeXSD2JS
             * @type Object
             * @private
             * @since 0.1
             **/

            datatypeXSD2JS = (function () {
                var xsdns = namespace.get(&#x27;xsd&#x27;),
                    table = [];
                table[xsdns + &quot;float&quot;]    = &#x27;number&#x27;;
                table[xsdns + &quot;decimal&quot;]  = &#x27;number&#x27;;
                table[xsdns + &quot;int&quot;]      = &#x27;number&#x27;;
                table[xsdns + &quot;integer&quot;]  = &#x27;number&#x27;;
                table[xsdns + &quot;long&quot;]     = &#x27;number&#x27;;
                table[xsdns + &quot;boolean&quot;]  = &#x27;boolean&#x27;;
                table[xsdns + &quot;date&quot;]     = &#x27;date&#x27;;
                table[xsdns + &quot;dateTime&quot;] = &#x27;datetime&#x27;;
                table[xsdns + &quot;time&quot;]     = &#x27;timeofday&#x27;;
                return table;
            }()),


            /** 
             * Converts XSD datatypes into Google JSON datatypes. 
             * 
             * See also property &#x60;datatypeXSD2JS&#x60;.
             * @method getGoogleJsonDatatype
             * @private
             * @param {string} sdatatype An XSD datatype, full URL.
             * @return {string} gdatatype, defaults to &#x60;string&#x60;
             * @since 0.1
             **/
            getGoogleJsonDatatype = function (sdatatype) {
                return datatypeXSD2JS[sdatatype] || &#x27;string&#x27;;
            },

           /** Converts results values into Google JSON values
            * according to the Google JSON datatype, i.e., values
            * other than strings and booleans need special
            * treatment. If the value is an URL, we &quot;prefixify&quot; it.
            * 
            * See also &#x60;sgvizler.namespace.prefixify&#x60;
            * 
            * @method getGoogleJsonValue
            * @private
            * @param {string|number|boolean} value The value from the SPARQL result set.
            * @param {string} gdatatype The Google JSON datatype.
            * @param {string} stype The &#x60;type&#x60; of the value in the
            *  SPARQL endpoint, e.g. &#x60;uri&#x60; or &#x60;literal&#x60;.
            * @return {Date|number|string} The converted value.
            * @since 0.1
            **/
            getGoogleJsonValue = function (value, gdatatype, stype) {
                var newvalue;
                if (gdatatype === &#x27;number&#x27;) {
                    newvalue = Number(value);
                } else if (gdatatype === &#x27;date&#x27;) {
                    //assume format yyyy-MM-dd
                    newvalue = new Date(value.substr(0, 4),
                                        parseInt(value.substr(5, 2))-1,
                                        value.substr(8, 2));
                } else if (gdatatype === &#x27;datetime&#x27;) {
                    //assume format yyyy-MM-ddZHH:mm:ss
                    newvalue = new Date(value.substr(0, 4),
                                        parseInt(value.substr(5, 2))-1,
                                        value.substr(8, 2),
                                        value.substr(11, 2),
                                        value.substr(14, 2),
                                        value.substr(17, 2));
                } else if (gdatatype === &#x27;timeofday&#x27;) {
                    //assume format HH:mm:ss
                    newvalue = [value.substr(0, 2),
                                value.substr(3, 2),
                                value.substr(6, 2)];
                } else { // datatype === &#x27;string&#x27; || datatype === &#x27;boolean&#x27;
                    if (stype === &#x27;uri&#x27;) { // replace namespace with prefix
                        newvalue = namespace.prefixify(value);
                    }
                    newvalue = value;
                }
                return newvalue;
            };

        ///////////////////////////////////////////////////
        // PUBLICs

        return {

            /**
             * Converts a SPARQL XML result set into &quot;Google JSON&quot;,
             * see
             * https://developers.google.com/chart/interactive/docs/reference#DataTable.
             * @method convertXML
             * @protected
             * @param {Object} sxml The SPARQL XML result set.
             * @return {Object} Object literal ready for
             * &#x60;google.visualization.DataTable&#x60; consumption.
             * @since 0.2.2
             **/
            convertXML: function (sxml) {
                var c, clen, // column index.
                    r, // row index.
                    gcols = [],
                    grows = [],
                    gdatatype = [], // for easy reference of datatypes.
                    sresults = $(sxml).find(&#x27;sparql&#x27;).find(&#x27;results&#x27;).find(&#x27;result&#x27;);

                // Build gcols: find column names and datatypes.
                c = 0;
                $(sxml).find(&#x27;sparql&#x27;).find(&#x27;head&#x27;).find(&#x27;variable&#x27;).each(function () {
                    var sdatatype = null,
                        name = $(this).attr(&#x27;name&#x27;),
                        scell = null,
                        scells = $(sresults).find(&#x27;binding[name=&quot;&#x27; + name + &#x27;&quot;]&#x27;);
                    if (scells.length) {
                        scell = $(scells).first().children().first()[0]; // uri, literal element
                        sdatatype = $(scell).attr(&#x27;datatype&#x27;);
                    }
                    gdatatype[c] = getGoogleJsonDatatype(sdatatype);
                    gcols[c] = { id: name, label: name, type: gdatatype[c] };
                    c += 1;
                });

                // Build grows: get results.
                r = 0;
                $(sresults).each(function () {
                    var gvalue,
                        scells,
                        scell,
                        stype,
                        svalue,
                        grow = [];
                    for (c = 0, clen = gcols.length; c &lt; clen; c += 1) {
                        gvalue = null;
                        scells = $(this).find(&#x27;binding[name=&quot;&#x27; + gcols[c].id + &#x27;&quot;]&#x27;);
                        if (scells.length &amp;&amp;
                                $(scells).first().children().first() &amp;&amp;
                                $(scells).first().children().first()[0]) {
                            scell = $(scells).first().children().first()[0]; // uri, literal element
                            stype = scell.nodeName;
                            svalue = $(scell).first().text();
                            gvalue = getGoogleJsonValue(svalue, gdatatype[c], stype);
                        }
                        grow[c] = { v: gvalue };
                    }
                    grows[r] = { c: grow };
                    r += 1;
                });

                return { cols: gcols, rows: grows };
            },

            /**
             * Converts a SPARQL JSON result set into &quot;Google JSON&quot;,
             * see
             * https://developers.google.com/chart/interactive/docs/reference#DataTable.
             * @method convertJSON
             * @protected
             * @param {Object} stable The SPARQL JSON result set.
             * @return {Object} Object literal ready for
             * &#x60;google.visualization.DataTable&#x60; consumption.
             * @since 0.1
             **/
            convertJSON: function (stable) {
                var c, clen, // column index.
                    r, rlen, // row index.
                    srow,
                    grow,
                    gvalue,
                    sdatatype,
                    gcols = [],
                    grows = [],
                    gdatatype = [], // for easy reference of datatypes
                    scols = stable.head.vars,
                    srows = stable.results.bindings;

                // Build gcols: find column names and datatypes.
                for (c = 0, clen = scols.length; c &lt; clen; c += 1) {
                    // Find a row where there is a value for this column
                    // in order to determine correct datatype.
                    r = 0;
                    while (r + 1 &lt; srows.length &amp;&amp; srows[r][scols[c]] === undefined) {
                        r += 1;
                    }
                    sdatatype = (srows[r] &amp;&amp; (srows[r][scols[c]] &amp;&amp; srows[r][scols[c]].datatype)) || null;
                    gdatatype[c] = getGoogleJsonDatatype(sdatatype);
                    gcols[c] = { id: scols[c], label: scols[c], type: gdatatype[c] };
                }

                // Build grows.
                // loop rows
                for (r = 0, rlen = srows.length; r &lt; rlen; r += 1) {
                    srow = srows[r];
                    grow = [];
                    // loop cells
                    for (c = 0, clen = scols.length; c &lt; clen; c += 1) {
                        gvalue = null;
                        if (srow[scols[c]] &amp;&amp; srow[scols[c]].value) {
                            gvalue = getGoogleJsonValue(srow[scols[c]].value, gdatatype[c], srow[scols[c]].type);
                        }
                        grow[c] = { v: gvalue };
                    }
                    grows[r] = { c: grow };
                }

                return { cols: gcols, rows: grows };
            },

            /**
             * Returns number of results, SPARQL XML.
             * @method countXML
             * @protected
             * @param {Object} sxml The SPARQL XML result set.
             * @return {number} The number of result set rows.
             * @since 0.2.2
             */
            countXML: function (sxml) {
                return $(sxml).find(&#x27;sparql&#x27;).find(&#x27;results&#x27;).find(&#x27;result&#x27;).length;
            },

            /**
             * Returns number of results, SPARQL JSON.
             * @method countJSON
             * @protected
             * @param {Object} stable The SPARQL JSON result set.
             * @return {number} The number of result set rows.
             * @since 0.1
             */
            countJSON: function (stable) {
                return stable.results.bindings &amp;&amp; stable.results.bindings.length;
            }
        };

    }());


    /**
     * Loads dependencies for external functions.
     * 
     * Dependencies:
     * 
     *   - sgvizler.util
     *   - sgvizler.logger
     *   - sgvizler.registry
     *   - jQuery
     *   - google.load
     * 
     * @class sgvizler.loader
     * @static
     */
    S.loader = (function () {

        /*global $ */

        // Module dependencies:
        var util = S.util,
            logger = S.logger,
            registry = S.registry,
            moduleGooVis = registry.GVIZ,
            moduleGooMap = registry.GMAP,

            /** 
             * Contains a list of dependency loaders: function
             * name--deferred pairs. Keeps track of dependencies which
             * have already been asked for (but possibly not been
             * loaded yet).
             * 
             * @property loaders
             * @type Object
             * @private
             * @since 0.6.0
             **/
            loaders = {},

            /**
             * @method loadGVizScript
             * @private
             * @param {Array} [packages] List of
             * &#x60;google.visualization&#x60; packages to load.
             * @param {boolean} [loadLib] True if
             * &#x60;google.visualization&#x60; should be loaded even if
             * &#x60;packages&#x60; array is empty. This is needed in order to
             * load the &#x60;DataTable&#x60; class, which belongs to no
             * package.
             * @return {jQuery.Promise} Promise object which resolves
             * the loading of the given packages/library.
             * @since 0.6.0
             **/
            loadGVizScript = function (packages, loadLib) {
                /*global google */
                var loader,
                    promise = {},
                    packs = util.removeDuplicates(packages).sort(),
                    options;

                if (packs.length || loadLib) {
                    loader = $.Deferred();
                    options = {
                        callback: function () {
                            loader.resolve();
                            loaders[moduleGooVis].resolve(); // Always resolve google visualization loader.
                            logger.log(&quot;loadGVizScript: packages LOADED: &quot; + packs);
                        }
                    };

                    if (packs.length) {
                        options.packages = packs;
                    }
                    google.load(&#x27;visualization&#x27;, &#x27;1&#x27;, options);
                    logger.log(&quot;loadGVizScript: loading packages: &quot; + packs);

                    promise = loader.promise();
                }

                return promise;
            },

            /**
             * @method loadGMapScript
             * @private
             * @return {jQuery.Promise} Promise object which resolves
             * the loading of google.maps.
             * @since 0.6.0
             **/
            loadGMapScript = function () {
                /*global google */
                var loader = $.Deferred(),
                    options = {
                        other_params: &quot;sensor=false&quot;,
                        callback: function () {
                            loader.resolve();
                            logger.log(&quot;loadGVizScript: google.maps. LOADED: &quot;);
                        }
                    };
                google.load(&#x27;maps&#x27;, &#x27;3&#x27;, options);
                logger.log(&quot;loadGMapScript: loading google.maps.&quot;);

                return loader.promise();
            },

            /**
             * Load the dependencies of all the given function
             * names---as specified in &#x60;sgvizler.registry&#x60;.
             * @method loadDependencies
             * @protected
             * @param {Array|string} functions A list of function
             * names (or just a single function name) to load
             * dependencies for.
             * @return {jQuery.Promise} A promise object which
             * resolves the loading of all function dependencies.
             * @example loadDependencies(&#x27;google.visualization.Map&#x27;);
             *     returns deferred which will load the dependencies
             *     for the &#x60;google.visualization.Map&#x60; function as
             *     specified by &#x60;sgvizler.registry&#x60;.
             * @since 0.6.0
             **/
            loadDependencies = function (functions) {
                var i, ilen,
                    func,
                    deferreds = [], // Collect an array of deferreds.
                    gVizPacks = [],    // List of google visualization packages to collect.
                    gLoader,
                    deps,
                    dep,
                    loadGLib;

                functions = util.removeDuplicates(util.toArray(functions));

                while (functions.length) {

                    func = functions.pop();
                    deps = registry.getDependencies(func);

                    for (dep in deps) {
                        if (deps.hasOwnProperty(dep)) {
                            // Dependency is already loaded/loading.
                            if (loaders[deps[dep]]) {
                                deferreds.push(loaders[deps[dep]]);
                            } else if (util.getObjectByPath(dep) === undefined) {
                                // If it is a googleViz function, then collect package in an array.
                                if (util.startsWith(dep, moduleGooVis)) {
                                    // Special handling of DataTable.
                                    if (dep === registry.DATATABLE) {
                                        loadGLib = true;
                                        loaders[deps[dep]] = $.Deferred();
                                    } else {
                                        gVizPacks.push(deps[dep]);
                                    }
                                } else if (util.startsWith(dep, moduleGooMap)) {
                                    loaders[deps[dep]] = loadGMapScript();
                                    deferreds.push(loaders[deps[dep]]);
                                    logger.log(&quot;loadDependencies: loading script: &quot; + deps[dep]);
                                } else {
                                    // Assume dependency is a link to a javascript.
                                    loaders[deps[dep]] = $.getScript(deps[dep])
                                        .done(function () { logger.log(&quot;loadDependencies: loaded: &quot; + deps[dep]); });
                                    deferreds.push(loaders[deps[dep]]);
                                    logger.log(&quot;loadDependencies: loading script: &quot; + deps[dep]);
                                }
                            }
                        }
                    }
                }
                // If there are GViz packages, collect them to one deferred.
                if (gVizPacks.length || loadGLib) {
                    gLoader = loadGVizScript(gVizPacks, loadGLib);
                    deferreds.push(gLoader);

                    // Register this gLoader with all input function
                    // dependencies solved by this loader.
                    for (i = 0, ilen = gVizPacks.length; i &lt; ilen; i += 1) {
                        loaders[gVizPacks[i]] = gLoader;
                    }
                }
                // Sending array of arguments to when(). See http://bugs.jquery.com/ticket/8256.
                return $.when.apply($, deferreds);
            };

        /////////////////////////////////////////////////
        // PUBLICs

        return {
            loadDependencies: loadDependencies
        };
    }());

    /**
     * A set of default values used mostly, if not only, by the
     * sgvizler.Query class. These values may be get and set by the
     * get-setters of the sgvizler class.
     *
     * Dependencies:
     *
     *   - sgvizler.registry
     *
     * @class sgvizler.defaults
     * @static
     */
    S.defaults = (function () {

        // Module dependencies
        var moduleGooVis = S.registry.GVIZ,

            // Note: all property names must be lowercase.
            queryDefaults = {
                query: &quot;SELECT ?class (count(?instance) AS ?noOfInstances)\n&quot; +
                    &quot;WHERE{ ?instance a ?class }\n&quot; +
                    &quot;GROUP BY ?class\n&quot; +
                    &quot;ORDER BY ?class&quot;,
                froms: [],
                endpoint: &quot;http://sws.ifi.uio.no/sparql/world&quot;,
                endpoint_output_format: &#x27;json&#x27;,  // xml, json, jsonp
                endpoint_results_urlpart: &quot;?output=text&amp;amp;query=&quot;,
                validator_url: &quot;http://sparql.org/validate/query&quot; +
                    &quot;?languageSyntax=SPARQL&quot; +
                    &quot;&amp;amp;outputFormat=sparql&quot; +
                    &quot;&amp;amp;linenumbers=true&quot; +
                    &quot;&amp;amp;query=&quot;,
                chart: moduleGooVis + &#x27;.Table&#x27;,
                loglevel: 2
            },

            chartDefaults = {
                width:  800,
                height: 400,
                chartArea: {
                    left:   &#x27;5%&#x27;,
                    top:    &#x27;5%&#x27;,
                    width:  &#x27;75%&#x27;,
                    height: &#x27;80%&#x27;
                }
            },
            chartSpecificDefaults = (function () {
                var options = {};
                options[moduleGooVis + &#x27;.GeoMap&#x27;] = {
                    dataMode: &#x27;markers&#x27;
                };
                options[moduleGooVis + &#x27;.Map&#x27;] = {
                    dataMode: &#x27;markers&#x27;
                };
                options[moduleGooVis + &#x27;.Sparkline&#x27;] = {
                    showAxisLines: false
                };
                return options;
            }());
        return {
            /**
             * Collects query option default values. Should only be
             * used if you want to edit this values persistently
             * (passed by reference). If you want a copy of these
             * values, use method &#x60;getQueryOptions&#x60;.
             *
             * @property query
             * @type Object
             * @protected
             * @since 0.6.0
             **/
            query: queryDefaults,

            /**
             * Collects chart option default values. Should only be
             * used if you want to edit this values persistently
             * (passed by reference). If you want a copy of these
             * values, use method &#x60;getChartOptions&#x60;.
             *
             * @property chart
             * @type Object
             * @protected
             * @since 0.6.0
             **/
            chart: chartDefaults,

            /**
             * @method getQueryOptions
             * @protected
             * @return {Object} A copy of the query default options.
             * @since 0.6.0
             **/
            getQueryOptions: function () {
                return $.extend({}, queryDefaults);
            },

            /**
             * @method getChartOptions
             * @protected
             * @return {Object} A copy of the chart default options.
             * @since 0.6.0
             **/
            getChartOptions: function () {
                return $.extend({}, chartDefaults);
            },

            /**
             * @method getChartSpecificOptions
             * @protected
             * @param {String} chart The function name to retrieve options for, e.g., &#x60;&#x27;google.visualization.Map&#x27;&#x60;.
             * @return {Object} A copy of the chart specific default options.
             * @since 0.6.0
             **/
            getChartSpecificOptions: function (chart) {
                return $.extend({}, chartSpecificDefaults[chart]);
            },

            /**
             * @method setChartSpecificOption
             * @protected
             * @param {String} chart The function name to set the option for, e.g., &#x60;&#x27;google.visualization.Map&#x27;&#x60;.
             * @param {String} option The name of the option to set.
             * @param {String} value The value to set.
             * @example
             *     setChartSpecificOption(&#x27;google.visualization.Map&#x27;, &#x27;dataMode&#x27;, &#x27;markers&#x27;);
             *   sets the &#x60;&#x27;dataMode&#x27;&#x60; option for the
             *   &#x60;&#x27;google.visualization.Map&#x27;&#x60; function to the value
             *   &#x60;&#x27;markers&#x27;&#x60;.
             * @since 0.6.0
             **/
            setChartSpecificOption: function (chart, option, value) {
                chartSpecificDefaults[chart] = chartSpecificDefaults[chart] || {};
                chartSpecificDefaults[chart][option] = value;
            }
        };
    }());

    /**
     * Important class. Runs SPARQL query against SPARQL
     * endpoints.
     *
     * Dependencies:
     *
     *   - sgvizler.util
     *   - sgvizler.namespace
     *   - sgvizler.registry
     *   - sgvizler.parser
     *   - sgvizler.loader
     *   - sgvizler.logger
     *   - sgvizler.defaults
     *   - jQuery
     *   - google.visualization
     * 
     * 
     * Example of how to use the Query class:
     * 
     *     var sparqlQueryString = &quot;SELECT * {?s ?p ?o} LIMIT 10&quot;,
     *         containerID = &quot;myElementID&quot;,
     *         Q = new sgvizler.Query();
     * 
     *     // Note that default values may be set in the sgvizler object.
     *     Q.query(sparqlQueryString)
     *         .endpointURL(&quot;http://dbpedia.org/sparql&quot;)
     *         .endpointOutputFormat(&quot;json&quot;)                    // Possible values &#x27;xml&#x27;, &#x27;json&#x27;, &#x27;jsonp&#x27;.
     *         .chartFunction(&quot;google.visualization.BarChart&quot;)  // The name of the function to draw the chart.
     *         .draw(containerID);                              // Draw the chart in the designated HTML element.
     *
     * @class sgvizler.Query
     * @constructor
     * @param {Object} queryOptions
     * @param {Object} chartOptions
     * @since 0.5
     **/

    // Note: the parameter names in the documention are different just
    // for better readability.
    S.Query = function (queryOpt, chartOpt) {

        /*global $ */

        // Module dependencies:
        var util = S.util,
            getset = util.getset,
            prefixesSPARQL = S.namespace.prefixesSPARQL,
            registry = S.registry,
            moduleGooVis = registry.GVIZ,
            fDataTable = registry.DATATABLE,
            parser = S.parser,
            loadDependencies = S.loader.loadDependencies,
            logger = S.logger,
            defaults = S.defaults,

            /* Constants for query formats (qf) */
            qfXML = &#x27;xml&#x27;,
            qfJSON = &#x27;json&#x27;,
            qfJSONP = &#x27;jsonp&#x27;,

            /**
             * Contains properties relevant for query business. Get
             * and set values using get/setter functions.
             *
             * Default values are found in sgvizler.defaults (these
             * may be get/set with the get/setter function on the
             * sgvizler class) and are loaded on construction---and
             * get overwritten by properties in the constructed
             * parameter.
             * @property queryOptions
             * @type Object
             * @private
             * @since 0.5
             **/
            queryOptions,

            /**
             * Contains properties relevant for chart drawing
             * business. Get and set values using get/setter
             * functions.
             *
             * Default values are found in sgvizler.defaults (these
             * may be get/set with the get/setter function on the
             * sgvizler class) and are loaded on construction---and
             * get overwritten by properties in the constructed
             * parameter.
             * @property chartOptions
             * @type Object
             * @private
             * @since 0.5
             **/
            chartOptions,

            //TODO
            listeners = {},

            /**
             * DataTable query results.
             * @property dataTable
             * @type google.visualization.DataTable
             * @private
             * @since 0.5
             **/
            dataTable,

            /**
             * The raw results as retuned by the endpoint.
             * @property queryResult
             * @type Object either XML or JSON
             * @private
             * @since 0.5
             **/
            queryResult,

            /**
             * The number of rows in the query results.
             * @property noOfResults
             * @type number
             * @public
             * @since 0.5
             **/
            noOfResults,

            // TODO: better logging.
            // processQueryResults = function (data) {
            //     var noRows = getResultRowCount(data);
            //     if (noRows === null) {
            //         S.logger.displayFeedback(this, &quot;ERROR_UNKNOWN&quot;);
            //     } else if (noRows === 0) {
            //         S.logger.displayFeedback(this, &quot;NO_RESULTS&quot;);
            //     } else {
            //         S.logger.displayFeedback(this, &quot;DRAWING&quot;);
            //         return getGoogleJSON(data);
            //     }
            // },

            /**
             * Add a url as an RDF source to be included in the SPARQL
             * query in the &#x60;FROM&#x60; block.
             * @method addFrom
             * @public
             * @param {String} url
             * @since 0.5
             **/
            addFrom = function (url) {
                queryOptions.froms.push(url);
            },

            /**
             * Remove all registered FROMs.
             *
             * See also &#x60;addFrom&#x60;.
             * @method clearFroms
             * @public
             * @since 0.5
             **/
            clearFroms = function () {
                queryOptions.froms = [];
            },

            //// Getters/Setters
            // TODO redefine query function setters when query is
            // issued: only one query per Query.

           /**
            * Get query string.
            * @method query
            * @public
            * @return {string}
            */
           /**
            * Set query string.
            * @method query
            * @public
            * @param {string} queryString
            * @chainable
            */
            query = function (queryString) {
                if (queryString !== undefined) {
                    clearFroms();
                }
                return getset(&#x27;query&#x27;, queryString, queryOptions, this);
            },
            /**
             * Get endpoint URL.
             * @method endpointURL
             * @public
             * @return {string}
             * @since 0.5
             **/
            /**
             * Set endpoint URL.
             * @method endpointURL
             * @public
             * @param {string} url
             * @chainable
             * @example
             *     sgvizler.endpointURL(&#x27;http://sparql.dbpedia.org&#x27;);
             *   sets this Query object&#x27;s endpoint to DBpedia.
             * @since 0.5
             **/
            endpointURL = function (url) {
                return getset(&#x27;endpoint&#x27;, url, queryOptions, this);
            },

            /**
             * Get endpoint output format.
             * @method endpointOutputFormat
             * @public
             * @return {string}
             * @since 0.5
             **/
            /**
             * Set endpoint output format. Legal values are &#x60;&#x27;xml&#x27;&#x60;,
             * &#x60;&#x27;json&#x27;&#x60;, &#x60;&#x27;jsonp&#x27;&#x60;.
             * @method endpointOutputFormat
             * @public
             * @param {string} format
             * @chainable
             * @since 0.5
             **/
            endpointOutputFormat = function (format) {
                return getset(&#x27;endpoint_output_format&#x27;, format, queryOptions, this);
            },

            // TODO
            endpointResultsURLPart = function (value) {
                return getset(&#x27;endpoint_results_urlpart&#x27;, value, queryOptions, this);
            },

            /**
             * Get URL to online SPARQL query validator.
             * @method validatorURL
             * @public
             * @return {string}
             * @since 0.5
             **/
            /**
             * Set URL to online SPARQL query validator. Appending a
             * SPARQL query to the end of this URL should give a page
             * which validates the given query.
             * @method validatorURL
             * @public
             * @param {string} url
             * @chainable
             * @since 0.5
             * @example
             *     TODO
             **/
            validatorURL = function (url) {
                return getset(&#x27;validator_url&#x27;, url, queryOptions, this);
            },

            // TODO
            loglevel = function (value) {
                return getset(&#x27;loglevel&#x27;, value, queryOptions, this);
            },

            // TODO
            logContainer = function (value) {
                return getset(&#x27;logContainer&#x27;, value, queryOptions, this);
            },

            /**
             * Get the name of datatable preprocessing function.
             * @method datatableFunction
             * @public
             * @return {string}
             * @since 0.5
             **/
            /**
             * Set the name of datatable preprocessing function. The
             * function should be availble in the global object, or
             * registered with dependencies in Sgvizler&#x27;s registry;
             * see TODO
             * @method datatableFunction
             * @public
             * @param {string} functionName
             * @chainable
             * @since 0.5
             **/
            datatableFunction = function (functionName) {
                return getset(&#x27;datatable&#x27;, functionName, queryOptions, this);
            },

            /**
             * Get the name of chart function.
             * @method chartFunction
             * @public
             * @return {string}
             * @since 0.5
             **/
            /**
             * Set the name of chart function. The function should be
             * availble in the global object, or registered with
             * dependencies in Sgvizler&#x27;s registry; see TODO
             * @method chartFunction
             * @public
             * @param {string} functionName
             * @chainable
             * @since 0.5
             **/
            chartFunction = function (functionName) {
                return getset(&#x27;chart&#x27;, functionName, queryOptions, this);
            },

            /**
             * Get the height of the chart container.
             * @method chartHeight
             * @public
             * @return {string}
             * @since 0.5
             **/
            /**
             * Set the height of the chart container.
             * @method chartHeight
             * @public
             * @param {number} height
             * @chainable
             * @since 0.5
             **/
            chartHeight = function (height) {
                return getset(&#x27;height&#x27;, height, chartOptions, this);
            },

            /**
             * Get the width of the chart container.
             * @method chartWidth
             * @public
             * @return {string}
             * @since 0.5
             **/
            /**
             * Set the width of the chart container.
             * @method chartWidth
             * @public
             * @param {number} width
             * @chainable
             * @since 0.5
             **/
            chartWidth = function (width) {
                return getset(&#x27;width&#x27;, width, chartOptions, this);
            },

            /**
             * Get the query string with prefixes added and encoded
             * for URL insertion.
             * @method getEncodedQuery
             * @public
             * @return {String}
             * @since 0.5
             **/
            getEncodedQuery = function () {
                return encodeURIComponent(prefixesSPARQL() + query());
            },

            /**
             * Extends the query string by including the urls in
             * &#x60;from&#x60; as &#x60;FROM&#x60; statements in the (SPARQL) &#x60;query&#x60;.
             * @method insertFrom
             * @private
             * @since 0.5
             **/
            insertFrom = function () {
                var i, len = queryOptions.froms.length,
                    from;
                if (len) {
                    from = &quot;&quot;;
                    for (i = 0; i &lt; len; i += 1) {
                        from += &#x27;FROM &lt;&#x27; + queryOptions.froms[i] + &#x27;&gt;\n&#x27;;
                    }
                    query(query().replace(/((WHERE)?(\s)*\{)/i, &#x27;\n&#x27; + from + &#x27;$1&#x27;));
                }
            },

            /**
             * Sets and returns &#x60;noOfResults&#x60;, i.e., the number of
             * rows in the query result.
             * @method getResultRowCount
             * @private
             * @param {google.visualization.DataTable} dataTable
             * @return {Number}
             * @since 0.5
             **/
            getResultRowCount = function (dataTable) {
                if (noOfResults === undefined) {
                    if (endpointOutputFormat() === qfXML) {
                        noOfResults = parser.countXML(dataTable);
                    } else {
                        noOfResults = parser.countJSON(dataTable);
                    }
                }
                return noOfResults;
            },

            /**
             * Converts &quot;raw&quot; query results into Google JSON, using
             * sgvizler.parser.
             * @method getGoogleJSON
             * @private
             * @param {Object} data Query result set
             * @return {JSON} JSON edable by google.visualization.DataTable
             * @since 0.5
             **/
            getGoogleJSON = function (data) {
                var gJSON = {};
                if (getResultRowCount(data)) {
                    if (endpointOutputFormat() === qfXML) {
                        gJSON = parser.convertXML(data);
                    } else {
                        gJSON = parser.convertJSON(data);
                    }
                }
                return gJSON;
            },

            // TODO: add different listeners. onQuery, onResults, onDraw?
            /**
             * Add a function which is to be fired when the
             * listener named &#x60;name&#x60; is fired.
             *
             * See &#x60;fireListener&#x60;
             *
             * @method addListener
             * @private
             * @param {String} name The name of the listener.
             * @param {Function} func The function to fire.
             * @example
             *     addListener(&quot;ready&quot;, function () { console.log(&quot;Ready!&quot;) });
             * @since 0.6.0
             **/
            addListener = function (name, func) {
                if (typeof func === &#x27;function&#x27;) { // accept only functions.
                    listeners[name] = listeners[name] || [];
                    listeners[name].push(func);
                } else {
                    throw new TypeError();
                }
            },

            /**
             * Fires (runs, executes) all functions registered
             * on the listener &#x60;name&#x60;.
             *
             * See &#x60;addListener&#x60;.
             *
             * @method fireListener
             * @private
             * @param {String} name The name of the listener.
             * @since 0.6.0
             **/
            fireListener = function (name) {
                if (listeners[name]) {
                    while (listeners[name].length) {
                        (listeners[name].pop())(); // run function.
                    }
                }
            },

            /**
             * Sends query to endpoint using AJAX. &quot;Low level&quot; method,
             * consider using &#x60;saveQueryResults()&#x60;.
             * @method sendQuery
             * @private
             * @async
             * @return {jQuery.Promise} A Promise containing the query results.
             * @since 0.5
             **/
            // TODO .fail, .progress: logging.
            sendQuery = function () {
                var promise, // query promise.
                    myEndpointOutput = endpointOutputFormat();

                insertFrom();

                if (myEndpointOutput !== qfJSONP &amp;&amp;
                        window.XDomainRequest) {

                    // special query function for IE. Hiding variables in inner function.
                    // TODO See: https://gist.github.com/1114981 for inspiration.
                    promise = (
                        function () {
                            /*global XDomainRequest */
                            var qx = $.Deferred(),
                                xdr = new XDomainRequest(),
                                url = endpointURL() +
                                    &quot;?query=&quot; + getEncodedQuery() +
                                    &quot;&amp;output=&quot; + myEndpointOutput;
                            xdr.open(&quot;GET&quot;, url);
                            xdr.onload = function () {
                                var data;
                                if (myEndpointOutput === qfXML) {
                                    data = $.parseXML(xdr.responseText);
                                } else {
                                    data = $.parseJSON(xdr.responseText);
                                }
                                qx.resolve(data);
                            };
                            xdr.send();
                            return qx.promise();
                        }()
                    );
                } else {
                    promise = $.ajax({
                        url: endpointURL(),
                        data: {
                            query: prefixesSPARQL() + query(),
                            output: (myEndpointOutput === qfJSONP) ? qfJSON : myEndpointOutput
                        },
                        dataType: myEndpointOutput
                    });
                }
                return promise;
            },

            /**
             * Saves the query result set in the private property
             * &#x60;results&#x60;. Works like a wrapper for sendQuery().
             *
             * See also saveDataTable().
             *
             * @TODO: also put the results in the promise object---and
             * how to get them out?
             *
             * @method saveQueryResults.
             * @private
             * @async
             * @return {jQuery.Promise} A Promise which resolves when
             * the results are saved.
             * @since 0.5
             **/
            saveQueryResults = function () {
                var qr;

                if (queryResult !== undefined) {
                    qr = queryResult;
                } else {
                    qr = sendQuery();
                    qr.fail(
                        function (xhr, textStatus, thrownError) {
                            logger.log(&quot;Error: A &#x27;&quot; + textStatus + &quot;&#x27; occurred in Query.saveQueryResults()&quot;);
                            fireListener(&#x27;onFail&#x27;);
                        }
                    );
                    // add callback to save query results in object.
                    qr.done(
                        function (data) {
                            queryResult = data;
                            fireListener(&#x27;onDone&#x27;);
                        }
                    );
                }
                return qr;
            },

            /**
             * Converts the the query result set into a
             *  google.visualization.DataTable, and if specified,
             *  applies datatable preprocessing function, and saves
             *  the datatable in the private property
             *  &#x60;dataTable&#x60;.
             *
             * @TODO: also put the results in the promise object---and
             * how to get them out?
             *
             * @method saveDataTable
             * @private
             * @async
             * @return {jQuery.Promise} A Promise which resolves when
             * the datatable is saved.
             * @since 0.5
             **/
            saveDataTable = function () {
                /*global google */
                var qdt, // query data table.
                    myDatatableFunction = datatableFunction();

                if (dataTable) { // dataTable already computed.
                    qdt = dataTable;
                } else {
                    qdt =
                        $.when(
                            saveQueryResults(),
                            loadDependencies(fDataTable),
                            // Get possible preprocess function.
                            (function () {
                                var loader = {};
                                if (myDatatableFunction) {
                                    loader = loadDependencies(myDatatableFunction);
                                }
                                return loader;
                            }())
                        )
                        //TODO .fail(function () {})
                        .done(
                            function () {
                                dataTable = new google.visualization.DataTable(getGoogleJSON(queryResult));
                                if (myDatatableFunction) {
                                    var func = util.getObjectByPath(myDatatableFunction);
                                    dataTable = func(dataTable);
                                }
                            }
                        );
                    // TODO .fail, .progress: logging.
                }
                return qdt;
            },

            /**
             * Draws the result of the query in a given container.
             * @method draw
             * @public
             * @param {String} containerId The elementId of the
             * container to draw the result of the query.
             * @since 0.5
             **/
            draw = function (containerId) {
                /*global google */
                // Get query results and necessary charting functions in parallel,
                // then draw chart in container.

                var myChart = chartFunction();

                $.when(saveDataTable(),
                       loadDependencies(myChart))
                    .then(
                        function () {
                            try {
                                // chart is loaded by loadDependencies.
                                var Func = util.getObjectByPath(myChart),
                                    chartFunc = new Func(document.getElementById(containerId)),
                                    ready = function () {
                                        logger.log(myChart + &quot; for &quot; + containerId + &quot; is ready.&quot;);
                                        fireListener(&#x27;onDraw&#x27;);
                                    };

                                // log when chart is loaded.
                                if (util.startsWith(myChart, moduleGooVis)) {
                                    google.visualization.events.addListener(chartFunc, &#x27;ready&#x27;, ready);
                                } else if (chartFunc.addListener) {
                                    chartFunc.addListener(&#x27;ready&#x27;, ready);
                                }

                                // dataTable is set by saveDataTable.
                                chartFunc.draw(dataTable, chartOptions);
                            } catch (x) {
                                // TODO: better error reporting, what went wrong?
                                logger.log(myChart + &quot; -- &quot; + x);
                            }
                        }
                    );
            };

        /////////////////////////////////////////////////////////
        // Initialize things.

        // Load default values, and overwrite them with values given
        // in constructer parameters.
        queryOptions = $.extend(defaults.getQueryOptions(),
                                queryOpt);
        chartOptions = $.extend(defaults.getChartOptions(),
                                defaults.getChartSpecificOptions(chartFunction()),
                                chartOpt);

        // Safeguard constructor.
        if (!(this instanceof S.Query)) {
            throw new Error(&quot;Constructor &#x27;Query&#x27; called as a function. Use &#x27;new&#x27;.&quot;);
        }

        ////////////////////////////////////////////////////////
        // PUBLICs

        return {

            //// attributes
            noOfResults: noOfResults,

            //// functions
            draw: draw,
            getEncodedQuery: getEncodedQuery,

            // listeners
            onFail: function (func) {
                addListener(&#x27;onFail&#x27;, func);
            },
            onDone: function (func) {
                addListener(&#x27;onDone&#x27;, func);
            },
            onDraw: function (func) {
                addListener(&#x27;onDraw&#x27;, func);
            },

            /**
             * @method getDataTable
             * @public
             * @param {Function} success
             * @param {Function} fail
             * @async
             * @beta
             */
            getDataTable: function (success, fail) {
                $.when(saveDataTable())
                    .then(
                        function () {
                            var data = dataTable.clone();
                            success(data);
                        },
                        function () {
                            var data = dataTable.clone();
                            fail(data);
                        }
                    );
            },
            // TODO
            /*getQueryResults : function (success, fail) {
                $.when(saveQueryResults()).then(success(queryResult), fail);
            },
            getGoogleJSON: function (success, fail) {
                getQueryResults(
                    function (queryResult) {
                        success(getGoogleJSON(queryResult));
                    },
                    fail
                );
            },*/

            //// FROM
            addFrom: addFrom,
            clearFroms: clearFroms,

            //// Getters/setters. Cascade pattern.
            query: query,
            endpointURL: endpointURL,
            endpointOutputFormat: endpointOutputFormat,
            endpointResultsURLPart: endpointResultsURLPart,
            validatorURL: validatorURL,
            loglevel: loglevel,
            logContainer: logContainer,
            datatableFunction: datatableFunction,
            chartFunction: chartFunction,
            chartHeight: chartHeight,
            chartWidth: chartWidth
        };
    };

    /**
     * Draws charts specified in HTML containers, here we call them
     * &quot;sgvizler-containers&quot;.
     *
     * Example of use: The following sgvizler-container will be
     * selected by sgvizler due to the use of designated
     * attributes. The result is a pie chart (draw with
     * &#x60;google.visualization.PieChart&#x60;) showing the number of instance
     * per class in the endpoint at
     * &#x60;http://sws.ifi.uio.no/sparql/ndp&#x60;.
     *
     *     &lt;div id=&quot;ex1&quot;
     *          data-sgvizler-endpoint=&quot;http://sws.ifi.uio.no/sparql/npd&quot;
     *          data-sgvizler-query=&quot;SELECT ?class (count(?instance) AS ?noOfInstances)
     *                               WHERE{ ?instance a ?class }
     *                               GROUP BY ?class
     *                               ORDER BY ?class&quot;
     *          data-sgvizler-chart=&quot;google.visualization.PieChart&quot;
     *          style=&quot;width:800px; height:400px;&quot;&gt;&lt;/div&gt;
     *
     * These container must have an id attribute (or else sgvizler
     * will not know where to put the chart) and a query attribute (or
     * else the container will be ignored by sgvizler).
     *
     * Dependencies:
     *
     *  - sgvizler.util
     *  - sgvizler.loader
     *  - sgvizler.logger
     *  - sgvizler.Query
     *  - jQuery
     *
     * @class sgvizler.container
     * @static
     */

    S.container = (function () {

        /*global $ */

        // Module dependencies:
        var util = S.util,
            loadDependencies = S.loader.loadDependencies,
            logger = S.logger,
            Query = S.Query,

            // CONSTANTS
            /**
             * The prefix of attributes which values designated for
             * sgvizler should be given. Currently &#x60;data-sgvizler-&#x60;.
             *
             * Note that &#x60;data-&#x60; prefixed attribute names is valid
             * HTML5.
             * @property PREFIX
             * @type string
             * @final
             * @private
             * @since 0.2
             **/
            PREFIX = &#x27;data-sgvizler-&#x27;,

            /**
             * The prefix of attributes which values designated for
             * sgvizler and which are sent to the chart function
             * should be given. Currently
             * &#x60;data-sgvizler-chart-options&#x60;.
             *
             * @property PREFIXCHART
             * @type string
             * @final
             * @private
             * @since 0.2
             **/
            PREFIXCHART = PREFIX + &#x27;chart-options&#x27;,

            /**
             * In attributes where multiple values may be given the
             * properties VALUEASSIGN and VALUESPILT decides how to
             * parse the attribute value into multiple name--value
             * pairs.
             * @property VALUEASSIGN
             * @type string
             * @final
             * @private
             * @since 0.2
             **/
            VALUEASSIGN = &#x27;=&#x27;,

            /**
             * In attributes where multiple values may be given the
             * properties VALUEASSIGN and VALUESPILT decides how to
             * parse the attribute value into multiple name--value
             * pairs.
             *
             * @property VALUESPILT
             * @type string
             * @final
             * @private
             * @since 0.2
             **/
            VALUESPLIT = &#x27;|&#x27;,

            /**
             * Collects values designated for sgvizler in the given
             * element---by element id.
             *
             * See also property PREFIX.
             *
             * @method getQueryAttributes
             * @private
             * @param {string} elementID The ID for which the attributes should be collected.
             * @return {Object} List of name--value pairs.
             * @since 0.2
             **/
            getQueryAttributes = function (elementID) {
                var i, len,
                    queryOpt = {},
                    elmAttrs = document.getElementById(elementID).attributes;
                for (i = 0, len = elmAttrs.length; i &lt; len; i += 1) {
                    if (util.startsWith(elmAttrs[i].name, PREFIX)) {
                        queryOpt[elmAttrs[i].name.substring(PREFIX.length)] = elmAttrs[i].value;
                    }
                }
                return queryOpt;
            },

            /**
             * Collects values designated for sgvizler, and which are
             * options to the chart function, in the given
             * element---by element id.
             *
             * See also property CHARTPREFIX.
             *
             * @method getChartAttributes
             * @private
             * @param {string} elementID The ID for which the attributes should be collected.
             * @return {Object} List of name--value pairs.
             * @since 0.2
             **/
            getChartAttributes = function (elementID) {
                var i, j, ilen, jlen,
                    options,
                    assignment,
                    path,
                    o,
                    chartOpt = {},
                    attrValue = $(&quot;#&quot; + elementID).attr(PREFIXCHART);
                if (attrValue !== undefined) {
                    options = attrValue.split(VALUESPLIT);
                    for (i = 0, ilen = options.length; i &lt; ilen; i += 1) {
                        assignment = options[i].split(VALUEASSIGN);
                        path = assignment[0].split(&quot;.&quot;);
                        o = chartOpt;
                        for (j = 0, jlen = path.length - 1; j &lt; jlen; j += 1) {
                            if (o[path[j]] === undefined) {
                                o[path[j]] = {};
                            }
                            o = o[path[j]];
                        }
                        o[path[j]] = assignment[1];
                    }
                }
                // get width and heigth from css. take only numbers.
                chartOpt.width = /(\d+)/.exec($(&quot;#&quot; + elementID).css(&#x27;width&#x27;))[1];
                chartOpt.height = /(\d+)/.exec($(&quot;#&quot; + elementID).css(&#x27;height&#x27;))[1];
                return chartOpt;
            },

            /**
             * Finds all sgvizler-containers on the page and loads
             * their dependencies in one go.
             * @method loadDependenciesOnPage
             * @private
             * @param {Array|string} [strFunctions] Array (or just a
             * single string) of function names to get in addition to
             * the functions specifies in sgvizler-containers.
             * @since 0.6.0
             **/
            loadDependenciesOnPage = function (strFunctions) {
                strFunctions = util.toArray(strFunctions);

                // Collect functions specified in html tags.
                $(&#x27;[&#x27; + PREFIX + &#x27;chart]&#x27;).each(function () {
                    strFunctions.push($(this).attr(PREFIX + &quot;chart&quot;));
                });
                logger.log(&quot;initializer: loading functions: &quot; + strFunctions);
                loadDependencies(strFunctions);
            },

            /**
             * Draws the sgvizler-containers with the given element id.
             * @method containerDraw
             * @public
             * @for sgvizler
             * @param {String} elementID
             * @since 0.6.0
             **/
            draw = function (elementID) {
                var queryOptions = getQueryAttributes(elementID),
                    chartOptions = getChartAttributes(elementID),
                    froms = (queryOptions.rdf &amp;&amp; queryOptions.rdf.split(VALUESPLIT)) || [],
                    query = new Query(queryOptions, chartOptions);

                while (froms.length) {
                    query.addFrom(froms.pop());
                }

                logger.log(&quot;drawing id: &quot; + elementID);
                query.draw(elementID);
            },

            /**
             * Draws all sgvizler-containers on page.
             * @method containerDrawAll
             * @public
             * @for sgvizler
             * @since 0.3
             **/
            drawAll = function () {
                // Load dependencies for charts found on page.
                loadDependenciesOnPage();

                // Draw all containers with sgvizler query string attribute.
                $(&#x27;[&#x27; + PREFIX + &#x27;query]&#x27;).each(function () {
                    draw($(this).attr(&quot;id&quot;));
                });
            };


         /////////////////////////////////////////
         // PUBLICs

        return {
            draw: draw,
            drawAll: drawAll
        };

    }());

    /**
     * Handles all UI business for the HTML form for writing, issuing
     * and drawing sgvizler queries.
     *
     * Dependencies:
     *
     *  - sgvizler.util
     *  - sgvizler.namespace
     *  - sgvizler.registry
     *  - sgvizler.Query
     *
     * @class sgvizler.form
     * @static
     **/
    S.form = (function () {

        /*global $ */

        // Module dependencies:
        var util = S.util,
            prefixesSPARQL = S.namespace.prefixesSPARQL,
            registry = S.registry,
            Query = S.Query,

            /**
             * Approx. 15 properties giving name to HTML elements
             * which appear in the form.
             * @property idXs
             * @type String
             * @private
             * @since 0.2
             **/
            idprefix  =         &#x27;sgvzlr_&#x27;,
            idMainCon =         idprefix + &#x27;mainCon&#x27;,
            idFormCon =         idprefix + &#x27;formCon&#x27;,
            idChartCon =        idprefix + &#x27;gchart&#x27;,      // #id to the container to hold the chart
            idQueryForm =       idprefix + &#x27;formQuery&#x27;,   //
            idQueryTxt =        idprefix + &#x27;cQuery&#x27;,      // query text area.
            idFormQuery =       idprefix + &#x27;strQuery&#x27;,    // hidden query string. &quot;trick&quot; taken from snorql.
            idFormEndpointGrp = idprefix + &#x27;strEndpointGrp&#x27;, //
            idFormEndpoint =    idprefix + &#x27;strEndpoint&#x27;, //
            idFormFormatGrp =   idprefix + &#x27;btnFormatGrp&#x27;,   //
            idFormFormat =      idprefix + &#x27;btnFormat&#x27;,   //
            idFormSizeGrp =     idprefix + &#x27;strSizeGrp&#x27;,    //
            idFormWidth =       idprefix + &#x27;strWidth&#x27;,    //
            idFormHeight =      idprefix + &#x27;strHeight&#x27;,   //
            idFormChartGrp =    idprefix + &#x27;optChartGrp&#x27;,    //
            idFormChart =       idprefix + &#x27;optChart&#x27;,    //
            idFormButtonGrp =   idprefix + &#x27;btnSendGrp&#x27;,    //
            idPrefixCon =       idprefix + &#x27;cPrefix&#x27;,     // print prefixes
            idMessageCon =      idprefix + &#x27;cMessage&#x27;,    // print messages
            idLogo =            idprefix + &#x27;logo&#x27;,
            idFooter =          idprefix + &#x27;footer&#x27;,

            /**
             * Contains groups of elements which make out the
             * form. Described using the array syntax edible by
             * sgvizler.util.createHTMLElement.
             * @property html
             * @type Object
             * @private
             * @since 0.6.0
             **/
            html = (function () {
                // Difficult to get whitespace correct while keeping it readable:
                /*jslint white: true */
                return {

                    /**
                     * The heading for the form: &quot;Sgvizler&quot;.
                     * @property html.heading
                     * @type Array
                     * @private
                     * @since 0.6.0
                     **/
                    heading: [&#x27;h1&#x27;, null, [&#x27;Sgvizler&#x27;]],

                    /**
                     * Logo pointing to homepage.
                     * @property html.logo
                     * @type Array
                     * @private
                     * @since 0.6.0
                     **/
                    logo: [&#x27;div&#x27;, { id: idLogo },
                           [
                               [&#x27;a&#x27;, { href: S.core.HOMEPAGE },
                                [
                                    [&#x27;img&#x27;,
                                     {
                                         src: S.core.LOGOIMAGE,
                                         alt: &quot;Mr. Sgvizler&quot;
                                     }
                                    ]
                                ]
                               ],
                               &#x27;Mr. Sgvizler&#x27;
                           ]
                          ],

                    /**
                     * The form.
                     * @property html.main
                     * @type Array
                     * @private
                     * @since 0.6.0
                     **/
                    main:
                    [&#x27;div&#x27;, { id: idFormCon },
                     [
                         // prefixes and namespaces.
                         [&#x27;pre&#x27;, { id: idPrefixCon } ],
                         // textarea for writing query.
                         [&#x27;textarea&#x27;, { id: idQueryTxt, rows: &#x27;10&#x27;, cols: &#x27;80&#x27; } ],
                         [&#x27;form&#x27;, { id: idQueryForm, method: &#x27;get&#x27; },
                          [
                              [&#x27;p&#x27;, null,
                               [
                                   // hidden query string
                                   [&#x27;input&#x27;,
                                    {
                                        id: idFormQuery,
                                        type: &#x27;hidden&#x27;,
                                        name: &#x27;query&#x27;,
                                        value: &#x27;&#x27;
                                    }
                                   ],
                                   [&#x27;span&#x27;, { &#x27;id&#x27;: idFormEndpointGrp }, [
                                        [&#x27;label&#x27;, { &#x27;for&#x27;: idFormEndpoint }, [&#x27;Endpoint: &#x27;] ],
                                        [&#x27;input&#x27;,
                                         {
                                             id: idFormEndpoint,
                                             type: &#x27;text&#x27;,
                                             name: &#x27;endpoint&#x27;,
                                             size: &#x27;30&#x27;
                                         }
                                        ]
                                    ]
                                   ],
                                   // format radio buttons
                                   [&#x27;span&#x27;, { &#x27;id&#x27;: idFormFormatGrp }, [
                                        [&#x27;label&#x27;, { &#x27;for&#x27;: idFormFormat }, [&#x27;Output format: &#x27;] ],
                                        [&#x27;input&#x27;,
                                         {
                                             id: idFormFormat,
                                             type: &#x27;radio&#x27;,
                                             name: &#x27;endpoint_output&#x27;,
                                             value: &#x27;xml&#x27;
                                         }
                                        ],
                                        &quot;xml &quot;,
                                        [&#x27;input&#x27;,
                                         {
                                             id: idFormFormat,
                                             type: &#x27;radio&#x27;,
                                             name: &#x27;endpoint_output&#x27;,
                                             value: &#x27;json&#x27;
                                         }
                                        ],
                                        &quot;json &quot;,
                                        [&#x27;input&#x27;,
                                         {
                                             id: idFormFormat,
                                             type: &#x27;radio&#x27;,
                                             name: &#x27;endpoint_output&#x27;,
                                             value: &#x27;jsonp&#x27;
                                         }
                                        ],
                                        &quot;jsonp&quot;
                                    ]
                                   ],

                                   // Chart type, dropdown.
                                   [&#x27;span&#x27;, { &#x27;id&#x27;: idFormChartGrp }, [
                                        [&#x27;label&#x27;, { &#x27;for&#x27;: idFormChart }, [&#x27;Chart type: &#x27;] ],
                                        [&#x27;select&#x27;,
                                         {
                                             id: idFormChart,
                                             name: &#x27;chart&#x27;
                                         }
                                        ]
                                    ]
                                   ],

                                   // Width, Height
                                   [&#x27;span&#x27;, { &#x27;id&#x27;: idFormSizeGrp }, [
                                        [&#x27;label&#x27;, { &#x27;for&#x27;: idFormWidth }, [&#x27;Width: &#x27;] ],
                                        [&#x27;input&#x27;,
                                         {
                                             id: idFormWidth,
                                             name: &#x27;width&#x27;,
                                             type: &#x27;text&#x27;,
                                             size: &#x27;3&#x27;
                                         }
                                        ],
                                        [&#x27;label&#x27;, { &#x27;for&#x27;: idFormHeight }, [&#x27;Height: &#x27;] ],
                                        [&#x27;input&#x27;,
                                         {
                                             id: idFormHeight,
                                             name: &#x27;height&#x27;,
                                             type: &#x27;text&#x27;,
                                             size: &#x27;3&#x27;
                                         }
                                        ]
                                    ]
                                   ],

                                   // Buttons
                                   [&#x27;span&#x27;, { &#x27;id&#x27;: idFormButtonGrp }, [
                                        [&#x27;input&#x27;,
                                         {
                                             type: &#x27;button&#x27;,
                                             value: &#x27;Reset&#x27;,
                                             onclick: &#x27;sgvizler.formReset()&#x27; // NB! must be the global function.
                                         }
                                        ],
                                        [&#x27;input&#x27;,
                                         {
                                             type: &#x27;button&#x27;,
                                             value: &#x27;Go&#x27;,
                                             onclick: &#x27;sgvizler.formSubmit()&#x27; // NB! must be the global function.
                                         }
                                        ]
                                    ]
                                   ]
                               ]
                              ]
                          ]
                         ],
                         // Logging container.
                         [&#x27;div&#x27;, { id: idMessageCon } ]
                     ]
                    ],

                    /**
                     * Container for holding the chart.
                     * @property html.chart
                     * @type Array
                     * @private
                     * @since 0.6.0
                     **/
                    chart:
                        [&#x27;div&#x27;,
                         {
                             id: idChartCon,
                             style: &quot;width:800px; height:400px;&quot;
                         }
                        ],

                    /**
                     * The footer
                     * @property html.footer
                     * @type Array
                     * @private
                     * @since 0.6.0
                     **/
                    footer:
                        [&#x27;div&#x27;,
                         {
                             id: idFooter
                         },
                         [
                             [&#x27;p&#x27;, null,
                              [
                                  [&#x27;a&#x27;, { href: S.core.HOMEPAGE },  [&#x27;Sgvizler&#x27;] ],
                                  &#x27; version &#x27; + S.core.VERSION +
                                      &#x27; (c) 2011&amp;ndash;2013 Martin G. Skj&amp;#230;veland.&#x27;
                              ]
                             ]
                         ]
                        ]
                };
            }()),

            /**
             * A list of permissible URL parameters. The parameter
             * name must be in this list to be read by the form.
             * @property permissible_urlparams
             * @type Array
             * @private
             * @since 0.3.1
             **/
            permissible_urlparams = [ &#x27;query&#x27;,
                                      &#x27;endpoint&#x27;,
                                      &#x27;endpoint_output&#x27;,
                                      &#x27;chart&#x27;,
                                      &#x27;width&#x27;,
                                      &#x27;height&#x27;,
                                      &#x27;ui&#x27;],

            /**
             * Tests if there really is an element with the give
             * element id.
             * @method isElement
             * @private
             * @param {String} elementID The element Id
             * @return {boolean} Returns true iff the element with
             * this element id exists.
             * @since 0.5
             **/
            isElement = function (elementID) {
                return $(&#x27;#&#x27; + elementID).length &gt; 0;
            },

            /**
             * Set a value for a given element. Is used to set the
             * value of form input fields.  Uses &#x60;jQuery.val&#x60;.
             * @method setElementValue
             * @private
             * @param {String} elementID The element id of the element to set value for.
             * @param {Primitive} value The value to set.
             * @since 0.5
             **/
            setElementValue = function (elementID, value) {
                if (isElement(elementID)) {
                    $(&#x27;#&#x27; + elementID).val(value);
                }
            },

            /**
             * Set the text for a given element. Is used to set the
             * text contents of containers.  Uses &#x60;jQuery.text&#x60;.
             * @method setElementText
             * @private
             * @param {String} elementID The element id of the element to set value for.
             * @param {String} text The value to set.
             * @since 0.5
             **/
            setElementText = function (elementID, text) {
                if (isElement(elementID)) {
                    $(&#x27;#&#x27; + elementID).text(text);
                }
            },
            /* UNUSED
             * Set the html content for a given element. Uses &#x60;jQuery.html&#x60;.
             * @method setElementHTML
             * @private
             * @param {String} elementID The element id of the element to set value for.
             * @param {String} html The value to set.
             * @since 0.6.0
             * setElementHTML = function (elementID, html) {
                if (isElement(elementID)) {
                    $(&#x27;#&#x27; + elementID).html(html);
                }
            },
             */

            /**
             * Displays the prefixes set in &#x60;sgvizler.namespace&#x60; as
             * SPARQL prefix declarations in the designated container.
             * @method displayPrefixes
             * @private
             * @since 0.1
             **/
            displayPrefixes = function () {
                setElementText(idPrefixCon, prefixesSPARQL());
            },

            /**
             * Displays query information in the form input fields,
             * e.g., the query string, query format, chart dimensions,
             * set in the input parameter.
             * @method displayUserInput
             * @param {sgvizler.Query} query
             * @private
             * @since 0.1
             **/
            displayUserInput = function (query) {
                setElementValue(idQueryTxt, query.query());
                setElementValue(idFormEndpoint, query.endpointURL());
                $(&#x27;input:radio[id=&#x27; + idFormFormat + &#x27;][value=&#x27; + query.endpointOutputFormat() + &#x27;]&#x27;).attr(&#x27;checked&#x27;, true);
                setElementValue(idFormChart, query.chartFunction());
                setElementValue(idFormWidth, query.chartWidth());
                setElementValue(idFormHeight, query.chartHeight());
            },

            /**
             * Populates the drop-down menu of available chart types
             * with the registered chart types found in the
             * &#x60;sgvizler.registry&#x60;, grouped by modules.
             * @method displayChartTypesMenu
             * @private
             * @since 0.2
             **/
            displayChartTypesMenu = function () {
                var i, j, ilen, jlen,
                    charts = registry.chartFunctions().sort(),
                    createOptGrp = function (name) {
                        return util.createHTMLElement(&#x27;optgroup&#x27;, { label: name + &#x27;.*&#x27; });
                    },
                    libs = registry.chartModules(),
                    group = {},
                    added = false;

                if (isElement(idFormChart)) {
                    // Create option groups for chart function modules.
                    for (j = 0, jlen = libs.length; j &lt; jlen; j += 1) {
                        group[libs[j]] = createOptGrp(libs[j]);
                        $(&#x27;#&#x27; + idFormChart).append(group[libs[j]]);
                    }

                    for (i = 0, ilen = charts.length; i &lt; ilen; i += 1) {
                        added = false;
                        for (j = 0, jlen = libs.length; j &lt; jlen; j += 1) {
                            if (util.startsWith(charts[i], libs[j])) {
                                $(group[libs[j]])
                                    .append($(&#x27;&lt;option/&gt;&#x27;)
                                            .val(charts[i])
                                            .html(charts[i].replace(libs[j] + &#x27;.&#x27;, &#x27;&#x27;)));
                                added = true;
                            }
                        }
                        if (!added) {
                            $(&#x27;#&#x27; + idFormChart).
                                append($(&#x27;&lt;option/&gt;&#x27;)
                                       .val(charts[i])
                                       .html(charts[i]));
                        }
                    }
                }
            },

            /**
             * Draws an intitially empty form on page. If elementID is
             * provided only the form and container for chart is
             * drawn; otherwise, a complete page, with header, logo
             * and footer, is draw directly in the body element.
             * @method createPage
             * @private
             * @param {String} [elementID=body]
             * @param {String} UItype values: &#x27;result&#x27;, &#x27;form&#x27; or &#x27;page&#x27;.
             * @since 0.6.0
             **/
            createUI = function (elementID, UItype) {
                var
                    createHTMLElements = function (elementsArray) {
                        return util.createHTMLElement.apply(undefined, elementsArray);
                    },
                    setChartContainer = function (elementID) {
                        if (elementID) {
                            idChartCon = elementID;
                        } else {
                            $(&#x27;body&#x27;).append(createHTMLElements(html.chart));
                        }
                    },
                    setForm = function (elementID) {
                        var main;
                        if (elementID) {
                            main = $(&#x27;#&#x27; + elementID);
                        } else { // add to body.
                            main = util.createHTMLElement(&#x27;div&#x27;, { id: idMainCon });
                            $(&#x27;body&#x27;).append(
                                createHTMLElements(html.logo),
                                createHTMLElements(html.heading),
                                main,
                                createHTMLElements(html.footer)
                            );
                        }
                        main.append(
                            createHTMLElements(html.main), // container for query business.
                            createHTMLElements(html.chart) // chart container.
                        );
                    };

                if (UItype === &#x27;result&#x27;) {
                    setChartContainer(elementID);
                } else {
                    setForm(elementID);
                }
            },

            /**
             * Displays prefix information, query information and
             * selections in the form, using other &#x60;displayX&#x60; methods.
             * @method displayUI
             * @private
             * @since 0.1
             **/
            displayUI = function (query) {
                displayPrefixes();
                displayChartTypesMenu();
                displayUserInput(query);
            },

            /**
             * Parses the current URL for parameters. Permissible
             * parameters are, if present, those listed in the input
             * of this method, or in the array
             * &#x60;permissible_urlparams&#x60;.
             * @method getUrlParams
             * @param {Array} [urlparams]
             * @private
             * @return {Object} A list of parameter--value pairs.
             * @since 0.1
             **/
            getUrlParams = function (urlparams) {
                /*jslint regexp: true */
                var urlParams = {},
                    e,
                    r = /([^&amp;=]+)=?([^&amp;]*)/g, // parameter, value pairs.
                    d = function (s) { return decodeURIComponent(s.replace(/\+/g, &quot; &quot;)); }, // replace &#x27;+&#x27; with space.
                    q = window.location.search.substring(1), // URL query string part.
                    params = urlparams || permissible_urlparams; // set defaults if necessary.

                while ((e = r.exec(q)) !== null) {
                    if (e[2].length &gt; 0 &amp;&amp; util.isInArray(e[1], params)) {
                        urlParams[d(e[1])] = d(e[2]);
                    }
                }
                return urlParams;
            },

            /**
             * &quot;Button method&quot; used to clear the form and load default
             * values. Does this by simply reloading the page without
             * any URL parameters.
             * @method formReset
             * @public
             * @for sgvizler
             * @since 0.1
             **/
            reset = function () {
                document.location = (window.location.href).replace(window.location.search, &quot;&quot;);
            },

            /**
             * &quot;Button method&quot; used to submit the form.
             * @method formSubmit
             * @public
             * @for sgvizler
             * @since 0.1
             **/
            submit = function () {
                $(&#x27;#&#x27; + idFormQuery).val($(&#x27;#&#x27; + idQueryTxt).val());
                $(&#x27;#&#x27; + idQueryForm).submit();
            },

            /**
             * Main method. Draws the form, gets possible URL
             * parameters, populates form with data, and, if
             * requested, sends a query and draws the chart in the
             * chart container.
             * @method formDraw
             * @param {String} [elementID=body]
             * @public
             * @for sgvizler
             * @since 0.1
             **/
            draw = function (elementID) {
                var params = getUrlParams(),
                    query = new Query(
                        {
                            query: params.query,
                            chart: params.chart,
                            endpoint: params.endpoint,
                            endpoint_output: params.endpoint_output
                        },
                        {
                            width: params.width,
                            height: params.height
                        }
                    );

                createUI(elementID, params.ui);
                displayUI(query);

                if (isElement(idChartCon) &amp;&amp; params.query) {
                    query.logContainer(idMessageCon);
                    query.draw(idChartCon);
                }
            };


        /////////////////////////////////////////////////////////////////
        // PUBLICs

        return {
            draw: draw,

            reset: reset,
            submit: submit
        };

    }());
    /**
     * .visualization
     * @main sgvizler.visualization
     */
    S.visualization = (function () {

        // Module dependencies:
        var util = S.util,
            namespace = S.namespace,
            charts = S.charts,

            C = {}, // sgvizler.visualization

            modSC = &quot;sgvizler.visualization&quot;;

        /** 
         * Make a html dt list.
         *
         * Format, 2--N columns:
         * 1. Term
         * 2--N. Definition
         * 
         * @class sgvizler.visualization.DefList
         * @extends sgvizler.charts.Chart
         * @constructor
         * @param {Object} container The container element where the
         * chart will be drawn.
         */

        /** 
         * Available options:
         * 
         *  - &#x27;cellSep&#x27;   :  string (can be html) to separate cells in definition columns. (default: &#x27; &#x27;)
         *  - &#x27;termPrefix  :  string (can be html) to prefix each term with. (default: &#x27;&#x27;)
         *  - &#x27;termPostfix :  string (can be html) to postfix each term with. (default: &#x27;:&#x27;)
         *  - &#x27;definitionPrefix  :  string (can be html) to prefix each definition with. (default: &#x27;&#x27;)
         *  - &#x27;definitionPostfix :  string (can be html) to postfix each definition with. (default: &#x27;&#x27;)
         * 
         * @method draw
         * @public
         * @param {google.visualization.DataTable} data
         * @param {Object} [chartOptions]
         * @since 0.3.0
         **/
        C.DefList = charts.add(modSC, &#x27;DefList&#x27;,
            function (data, chartOpt) {
                var r, noRows = data.getNumberOfRows(),
                    c, noColumns = data.getNumberOfColumns(),
                    opt = $.extend({ cellSep: &#x27; &#x27;,
                                     termPrefix: &#x27;&#x27;,
                                     termPostfix: &#x27;:&#x27;,
                                     definitionPrefix: &#x27;&#x27;,
                                     definitionPostfix: &#x27;&#x27; },
                                   chartOpt),
                    list = &quot;&quot;,
                    term,
                    definition;

                for (r = 0; r &lt; noRows; r += 1) {
                    term = &#x27;&lt;dt&gt;&#x27; +
                        opt.termPrefix +
                        C.util.linkify2String(data.getValue(r, 0)) +
                        opt.termPostfix +
                        &#x27;&lt;/dt&gt;&#x27;;
                    definition = &#x27;&lt;dd&gt;&#x27; +
                        opt.definitionPrefix;

                    for (c = 1; c &lt; noColumns; c += 1) {
                        definition += C.util.linkify2String(data.getValue(r, c));
                        if (c + 1 !== noColumns) {
                            definition += opt.cellSep;
                        }
                    }
                    definition += opt.definitionPostfix +
                        &#x27;&lt;/dd&gt;&#x27;;
                    list += term + definition;
                }

                $(this.container)
                    .empty()
                    .html(list);

                this.fireListener(&#x27;ready&#x27;);
            }
            );

        /** 
         * Make a standard simple html table.
         * 
         * @class sgvizler.visualization.Table
         * @extends sgvizler.charts.Chart
         * @constructor
         * @param {Object} container The container element where the
         * chart will be drawn.
         * @since 0.5.1
         **/

        /** 
         * Available options:
         *  - &#x27;headings&#x27;   :  &quot;true&quot; / &quot;false&quot;  (default: &quot;true&quot;)
         *
         * @method draw
         * @public
         * @param {google.visualization.DataTable} data
         * @param {Object} [chartOptions]
         * @since 0.5.1
         **/
        C.Table = charts.add(modSC, &quot;Table&quot;,
            function (data, chartOpt) {
                var c, noColumns = data.getNumberOfColumns(),
                    r, noRows = data.getNumberOfRows(),
                    opt = $.extend({ headings: true }, chartOpt),
                    table,
                    rows = [],
                    cells = [];

                if (opt.headings) {
                    for (c = 0; c &lt; noColumns; c += 1) {
                        cells.push([&#x27;th&#x27;, null, data.getColumnLabel(c)]);
                    }
                    rows.push([&#x27;tr&#x27;, null, cells]);
                }

                for (r = 0; r &lt; noRows; r += 1) {
                    cells = [];
                    for (c = 0; c &lt; noColumns; c += 1) {
                        cells.push([&#x27;td&#x27;, null, [C.util.linkify2HTMLElementArray(data.getValue(r, c))]]);
                    }
                    rows.push([&#x27;tr&#x27;, null, cells]);
                }

                table = util.createHTMLElement(&#x27;table&#x27;, null, rows);
                $(this.container).empty().html(table);

                this.fireListener(&#x27;ready&#x27;);
            }
            );

        /**
         * @class sgvizler.visualization.MapWKT
         * @extends sgvizler.charts.Chart
         * @constructor
         * @param {Object} container The container element where the
         * chart will be drawn.
         * @since 0.6.0
         **/

        /**
         * @method draw
         * @public
         * @param {google.visualization.DataTable} data
         * @param {Object} [chartOptions]
         * @since 0.6.0
         */
        C.MapWKT = charts.add(modSC, &quot;MapWKT&quot;,
            function (data, chartOpt) {
                /*global google, OpenLayers */
                var //c,
                    noColumns = data.getNumberOfColumns(),
                    r, noRows = data.getNumberOfRows(),
                    //that = this,
                    opt = $.extend(
                        {
                            zoom: 5,
                            centerLat: 62,
                            centerLong: 2,
                            //mapTypeId: google.maps.MapTypeId.TERRAIN,
                            //douglasPeuckerKink: 5000,
                            geoDatumIn: &quot;EPSG:4326&quot;,//&quot;EPSG:4230&quot;,
                            geoDatumOut: &quot;EPSG:4326&quot;
                        },
                        chartOpt
                    ),

                    mapOptions = {
                        projection: opt.geoDatumOut,
                        layers: [
                            new OpenLayers.Layer.OSM(),
                            // new OpenLayers.Layer.WMS(
                            //     &quot;OpenLayers WMS&quot;,
                            //     &quot;http://vmap0.tiles.osgeo.org/wms/vmap0?&quot;, {layers: &#x27;basic&#x27;}
                            // ),
                            new OpenLayers.Layer.Google(
                                &quot;Google Physical&quot;,
                                {type: google.maps.MapTypeId.TERRAIN}
                            ),
                            new OpenLayers.Layer.Google(
                                &quot;Google Streets&quot;,
                                {numZoomLevels: 20}
                            ),
                            new OpenLayers.Layer.Google(
                                &quot;Google Hybrid&quot;,
                                {type: google.maps.MapTypeId.HYBRID, numZoomLevels: 20}
                            ),
                            new OpenLayers.Layer.Google(
                                &quot;Google Satellite&quot;,
                                {type: google.maps.MapTypeId.SATELLITE, numZoomLevels: 22}
                            )
                        ],
                        controls: [
                            new OpenLayers.Control.Navigation(),
                            new OpenLayers.Control.PanZoomBar(),
                            new OpenLayers.Control.LayerSwitcher({ ascending: false }),
                            new OpenLayers.Control.Permalink(),
                            new OpenLayers.Control.ScaleLine(),
                            new OpenLayers.Control.MousePosition(),
                            new OpenLayers.Control.OverviewMap(),
                            new OpenLayers.Control.KeyboardDefaults()
                        ],
                        center: new OpenLayers.LonLat(opt.centerLong, opt.centerLat),
                        zoom: 5
                    },
                    mapBounds,
                    map = new OpenLayers.Map(this.container, mapOptions),

                    formatterWKT = new OpenLayers.Format.WKT(
                        {
                            internalProjection: map.baseLayer.projection,
                            externalProjection: new OpenLayers.Projection(opt.geoDatumIn)
                        }
                    ),

                    resultLayer = new OpenLayers.Layer.Vector(
                        &quot;Results&quot;,
                        {
                            styleMap: new OpenLayers.StyleMap(
                                {
                                    &#x27;default&#x27;: new OpenLayers.Style(
                                        {
                                            fillColor: &quot;#33CC00&quot;,
                                            fillOpacity: 0.2,
                                            strokeColor: &quot;#000000&quot;,
                                            strokeWidth: 1
                                        }
                                    )
                                }
                            )
                        }
                    ),
                    labelLayer = new OpenLayers.Layer.Vector(
                        &quot;Labels&quot;,
                        {
                            eventListeners: {
                                featureselected: function (evt) {
                                    var feature = evt.feature,
                                        popup = new OpenLayers.Popup.FramedCloud(
                                            &quot;popup&quot;,
                                            OpenLayers.LonLat.fromString(feature.geometry.toShortString()),
                                            null,
                                            &quot;&lt;div style=&#x27;font-size:.8em&#x27;&gt;&quot;
                                                + &quot;&lt;b&gt;&quot; + feature.attributes.name + &quot;&lt;/b&gt;&lt;br/&gt;&quot;
                                                + C.util.linkify2String(feature.attributes.uri) + &quot;&lt;br/&gt;&quot;
                                                + feature.attributes.description
                                                + &quot;&lt;/div&gt;&quot;,
                                            null,
                                            true
                                        );
                                    feature.popup = popup;
                                    map.addPopup(popup);
                                },
                                featureunselected: function (evt) {
                                    var feature = evt.feature;
                                    map.removePopup(feature.popup);
                                    feature.popup.destroy();
                                    feature.popup = null;
                                }
                            },
                            styleMap: new OpenLayers.StyleMap(
                                {
                                    &quot;default&quot;: new OpenLayers.Style(
                                        {
                                            strokeColor: &quot;#FF0000&quot;,
                                            strokeOpacity: 1,
                                            strokeWidth: 5,
                                            fillColor: &quot;#FF0000&quot;,
                                            fillOpacity: 0.5,
                                            pointRadius: 2,
                                            //pointerEvents: &quot;visiblePainted&quot;,

                                            label : &quot;${name}&quot;,
                                            fontSize: &quot;10px&quot;,
                                            fontFamily: &quot;Arial&quot;,
                                            labelAlign: &quot;l&quot;,
                                            labelOutlineColor: &quot;white&quot;,
                                            labelOutlineWidth: 1,
                                            labelXOffset : 7
                                        }
                                    )
                                }
                            )
                        }
                    ),

                    selector = new OpenLayers.Control.SelectFeature(
                        labelLayer,
                        {
                            click: true,
                            autoActivate: true
                        }
                    ),

                    wktFeature,
                    labelFeature,

                    addWKT = function (layer, valueWKT) {
                        var features = formatterWKT.read(valueWKT),
                            i;

                        if (features) {
                            if (!util.isArray(features.constructor)) {
                                features = [features];
                            }
                            for (i = 0; i &lt; features.length; i += 1) {
                                if (!mapBounds) {
                                    mapBounds = features[i].geometry.getBounds();
                                } else {
                                    mapBounds.extend(features[i].geometry.getBounds());
                                }
                            }
                            layer.addFeatures(features);
                        }
                        return features;
                    };

                //Proj4js.defs[&quot;EPSG:4230&quot;] = &quot;+proj=longlat +ellps=intl +no_defs&quot;;

                //////////////////////////////////////////////////////////////////////

                for (r = 0; r &lt; noRows; r += 1) {
                    // add WKT
                    wktFeature = addWKT(resultLayer, data.getValue(r, 0));

                    // add Label
                    labelFeature = new OpenLayers.Feature.Vector(wktFeature[0].geometry.getCentroid());

                    labelFeature.attributes.name =
                        (noColumns &gt; 1 &amp;&amp; data.getValue(r, 1)) ? data.getValue(r, 1) : &quot;&quot;;
                    labelFeature.attributes.uri =
                        (noColumns &gt; 2 &amp;&amp; data.getValue(r, 2)) ? data.getValue(r, 2) : &quot;&quot;;
                    labelFeature.attributes.description =
                        (noColumns &gt; 3 &amp;&amp; data.getValue(r, 3)) ? data.getValue(r, 3) : &quot;&quot;;

                    labelLayer.addFeatures([labelFeature]);
                }

                map.addLayer(resultLayer);
                map.addLayer(labelLayer);

                map.addControl(selector);

                map.zoomToExtent(mapBounds);

                this.fireListener(&#x27;ready&#x27;);

            },
            // Dependencies. { function: what-to-load }
            {
                &#x27;google.maps.Map&#x27;: &#x27;google.maps.Map&#x27;,
                &#x27;OpenLayers&#x27;: &#x27;//cdnjs.cloudflare.com/ajax/libs/openlayers/2.12/OpenLayers.min.js&#x27;
                //&#x27;GDouglasPeucker&#x27;: &#x27;http://www.bdcc.co.uk/Gmaps/GDouglasPeuker.js&#x27;,
                //&#x27;Proj4js&#x27;: &#x27;http://localhost/sgvizler/trunk/lib/proj4js-compressed.js&#x27;
            }
            );

        /**
         * Draws a graph with clickable and movable nodes.
         *
         * Input format:
         *
         *  - 7 columns, last three are optional.
         *  - each row represents a source node, a target node and an edge from source to target.
         *  - the URIs are the id&#x27;s for the nodes, and make the nodes clickable.
         *
         * Columns:
         *
         *  1. sourceURI
         *  2. sourceLabel
         *  3. targetURI
         *  4. targetLabel
         *  5. edgeLabel
         *  6. sourceColor
         *  7. targetColor
         *
         * @class sgvizler.visualization.DraculaGraph
         * @extends sgvizler.charts.Chart
         * @constructor
         * @param {Object} container The container element where the
         * chart will be drawn.
         * @beta
         * @author Magnus Stuhr, Martin G. Skj√¶veland
         */

        /**
         * @method draw
         * @public
         * @param {google.visualization.DataTable} data
         * @param {Object} [chartOptions]
         * @since 0.5.1
         */
        /*global Dracula */
        C.DraculaGraph = charts.add(modSC, &quot;DraculaGraph&quot;,
            function (data, chartOpt) {

                var row, numberOfRows = data.getNumberOfRows(),
                    i, len,
                    numberOfColumns = data.getNumberOfColumns(),

                    // set defaults.
                    opt = $.extend({
                        noderadius: 0.5,
                        nodefontsize: &quot;10px&quot;,
                        nodeheight: 20,
                        nodestrokewidth: &quot;1px&quot;,
                        directed: false,
                        nodecornerradius: &quot;1px&quot;,
                        nodepadding: 7,
                        nodecolor: &quot;green&quot;,
                        edgestroke: &quot;blue&quot;,
                        edgefill: &quot;blue&quot;,
                        edgestrokewidth: 1,
                        edgefontsize: &quot;10px&quot;,
                        edgeseparator: &quot;, &quot;
                    }, chartOpt),

                    graph = new Dracula.Graph(),
                    layouter,
                    renderer,
                    edge,
                    source,
                    target,
                    label,

                    // custom node rendering using Raphael.
                    nodeRenderer = function (color, URL) {
                        return function (r, n) {
                            return r.set()
                                // rectangle
                                .push(r.rect(n.point[0],
                                             n.point[1],
                                             n.label.length * opt.nodepadding,
                                             opt.nodeheight)
                                      .attr({fill: color,
                                             &#x27;stroke-width&#x27;: opt.nodestrokewidth,
                                             r : opt.nodecornerradius}))
                                // label inside rectangle
                                .push(r.text(n.point[0] + n.label.length * opt.nodepadding / 2,
                                             n.point[1] + opt.nodeheight / 2,
                                             n.label)
                                      .attr({&#x27;font-size&#x27;: opt.nodefontsize})
                                      .click(function () { if (URL) { window.open(namespace.unprefixify(URL)); } })
                                     );
                        };
                    },

                    // helper function.
                    addNode = function (URL, name, color) {
                        graph.addNode(URL, {label: name, render: nodeRenderer(color, URL)});
                        //console.log(&quot;add node - name: &quot; + name + &quot;, URL: &quot; + URL);
                    },
                    edges = {},
                    keys_edges = [];

                for (row = 0; row &lt; numberOfRows; row += 1) {
                    source = data.getValue(row, 0);
                    target = data.getValue(row, 2);

                    // add source node
                    // Note: does dracula take care of duplicates?
                    if (source) {
                        addNode(source,
                                data.getValue(row, 1) || source,
                                numberOfColumns &gt; 5 ? data.getValue(row, 5) : opt.nodecolor);
                    }
                    // add target node
                    if (target) {
                        addNode(target,
                                data.getValue(row, 3) || target,
                                numberOfColumns &gt; 6 ? data.getValue(row, 6) : opt.nodecolor);
                    }

                    // collect edge labels. Only one edge per pair of nodes,
                    // so we concatinate labels of multiple edges into one.
                    if (source &amp;&amp; target) {
                        label = &quot;&quot;;
                        // test if source--target pair is seen before:
                        if (edges[source + target] !== undefined) {
                            label = edges[source + target].label; // retrieve accumulated label.
                        } else {
                            keys_edges.push(source + target);
                        }

                        if (numberOfColumns &gt; 4 &amp;&amp; data.getValue(row, 4).length &gt; 0) {
                            if (label.length &gt; 0) {
                                label += opt.edgeseparator;
                            }
                            label += data.getValue(row, 4);
                        }

                        edges[source + target] = {
                            source: source,
                            target: target,
                            label: label
                        };
                    }
                }

                // add edges
                for (i = 0, len = keys_edges.length; i &lt; len; i += 1) {
                    edge = edges[keys_edges[i]];
                    //console.log(&quot;add edge - source: &quot; + edge.source + &quot;, target &quot; + edge.target);
                    graph.addEdge(edge.source, edge.target,
                                  { stroke: opt.edgestroke,
                                    directed: opt.directed,
                                    fill: opt.edgefill,
                                    label: edge.label,
                                    width: opt.edgestrokewidth,
                                    fontsize: opt.edgefontsize
                                  });
                }

                layouter = new Dracula.Graph.Layout.Spring(graph);
                layouter.layout();

                $(this.container).empty();
                renderer = new Dracula.Graph.Renderer.Raphael(
                    this.container,
                    graph,
                    opt.width,
                    opt.height,
                    { noderadius : opt.nodeheight * opt.noderadius}
                );
                renderer.draw();

                this.fireListener(&#x27;ready&#x27;);
            },
            { Dracula: &#x27;http://www.data2000.no/sgvizler/lib/raphael-dracula.min.js&#x27; }
            );

        /** 
         * Make an html table with links and images.
         * 
         * @class sgvizler.visualization.Table_pict
         * @extends sgvizler.charts.Chart
         * @constructor
         * @param {Object} container The container element where the
         * chart will be drawn.
         * @since 0.5.1
         **/

        /** 
         * Available options:
         *  - &#x27;headings&#x27;   :  &quot;true&quot; / &quot;false&quot;  (default: &quot;true&quot;)
         *  - &#x27;borders&#x27;    : any type of table from Bootstrap
         *  - &#x27;im_width&#x27;   : width of images in the table
         *  - &#x27;im_height&#x27;  : height of images in the table
         *
         * @method draw
         * @public
         * @param {google.visualization.DataTable} data
         * @param {Object} [chartOptions]
         * @since 0.5.1
         **/
        C.Table_pict = charts.add(modSC, &quot;Table_pict&quot;,
            function (data, chartOpt) {
                var c, noColumns = data.getNumberOfColumns(),
                    r, noRows = data.getNumberOfRows(),
                    opt = $.extend({ headings: true, 
                                     borders: &#x27;table table-bordered&#x27;, 
                                     im_width: &#x27;100&#x27;,
                                     im_height: &#x27;100&#x27;},
                                   chartOpt),
                    table,
                    rows = [],
                    cells = [];

                C.util.loadBOOTSTRAP();

                if (opt.headings) {
                    for (c = 0; c &lt; noColumns; c += 1) {
                        cells.push([&#x27;th&#x27;, null, data.getColumnLabel(c)]);
                    }
                    rows.push([&#x27;tr&#x27;, null, cells]);
                }
                // The false value returned by linkify2String in linkify allow
                // to check if the data (row r, col c) is an image
                for (r = 0; r &lt; noRows; r += 1) {
                    cells = [];
                    for (c = 0; c &lt; noColumns; c += 1) {
                        cells.push([&#x27;td&#x27;, null, [C.util.linkify2String(data.getValue(r, c), opt.im_width, opt.im_height)]]);
                    }
                    rows.push([&#x27;tr&#x27;, null, cells]);
                }

                table = util.createHTMLElement(&#x27;table&#x27;, {&#x27;class&#x27;: opt.borders}, rows);
                $(this.container).empty().html(table);

                this.fireListener(&#x27;ready&#x27;);
            }
            );
        /** 
         * Write text.
         *
         * Any number of columns. Everything is displayed as text.
         * 
         * @class sgvizler.visualization.Text
         * @extends sgvizler.charts.Chart
         * @constructor
         * @param {Object} container The container element where the
         * chart will be drawn.
         * @since 0.3.0
         **/

        /** 
         * Available options:
         * 
         *  - &#x27;cellSep&#x27;       :  string (can be html) to separate cells in each column. (default: &#x27;, &#x27;)
         *  - &#x27;cellPrefix     :  string (can be html) to prefix each cell with. (default: &#x27;&#x27;)
         *  - &#x27;cellPostfix    :  string (can be html) to postfix each cell  with. (default: &#x27;&#x27;)
         *  - &#x27;rowPrefix      :  string (can be html) to prefix each row with. (default: &#x27;&lt;p&gt;&#x27;)
         *  - &#x27;rowPostfix     :  string (can be html) to postfix each row with. (default: &#x27;&lt;/p&gt;&#x27;)
         *  - &#x27;resultsPrefix  :  string (can be html) to prefix the results with. (default: &#x27;&lt;div&gt;&#x27;)
         *  - &#x27;resultsPostfix :  string (can be html) to postfix the results with. (default: &#x27;&lt;/div&gt;&#x27;)
         *
         * @method draw
         * @public
         * @param {google.visualization.DataTable} data
         * @param {Object} [chartOptions]
         * @since 0.3.0
         **/
        C.Text = charts.add(modSC, &quot;Text&quot;,
            function (data, chartOpt) {
                var c, noColumns = data.getNumberOfColumns(),
                    r, noRows = data.getNumberOfRows(),
                    opt = $.extend({ cellSep: &#x27;, &#x27;,
                                     cellPrefix: &#x27;&#x27;, cellPostfix: &#x27;&#x27;,
                                     rowPrefix: &#x27;&lt;p&gt;&#x27;, rowPostfix: &#x27;&lt;/p&gt;&#x27;,
                                     resultsPrefix: &#x27;&lt;div&gt;&#x27;, resultsPostfix: &#x27;&lt;/div&gt;&#x27; },
                                   chartOpt),
                    text = opt.resultsPrefix,
                    row;


                for (r = 0; r &lt; noRows; r += 1) {
                    row = opt.rowPrefix;
                    for (c = 0; c &lt; noColumns; c += 1) {
                        row += opt.cellPrefix + C.util.linkify2String(data.getValue(r, c)) + opt.cellPostfix;
                        if (c + 1 !== noColumns) { // Don&#x27;t add for last element in row.
                            row += opt.cellSep;
                        }
                    }
                    text += row + opt.rowPostfix;
                }
                text += opt.resultsPostfix;

                $(this.container)
                    .empty()
                    .html(text);

                this.fireListener(&#x27;ready&#x27;);
            }
            );


        /**
         * Extends google.visualization.Map in markers dataMode. Draws
         * textboxes with heading, paragraph, link and image. 
         * 
         * Data Format 2--6 columns:
         * 
         *   1. lat
         *   2. long
         *   3. name  (optional)
         *   4. text  (optional)
         *   5. link  (optional)
         *   6. image (optional)
         * 
         * - If &lt; 4 columns, then behaves just as gMap
         * - Only 6 columns will be read, columns &gt; 6 are ignored.
         * 
         * @class sgvizler.visualization.Map
         * @extends sgvizler.charts.Chart
         * @constructor
         * @param {Object} container The container element where the
         * chart will be drawn.
         * @since 0.3.0
         **/

        /**
         * Same options available as for google.visualization.Map.
         * 
         * @method draw
         * @public
         * @param {google.visualization.DataTable} data
         * @param {Object} [chartOptions]
         * @since 0.3.0
         */
        C.Map = charts.add(modSC, &quot;Map&quot;,
            function (data, chartOpt) {
                /*global google */
                var c, noColumns = data.getNumberOfColumns(),
                    r, noRows = data.getNumberOfRows(),
                    that = this,
                    opt = $.extend({ dataMode: &#x27;markers&#x27;,
                                     showTip: true,
                                     useMapTypeControl: true
                                   },
                                   chartOpt),
                    chart,
                    newData,
                    newValue;

                C.util.loadCSS();

                // The idea is to put all columns &gt; 2 into the
                // 3. column with html formatting.

                if (noColumns &gt; 3) {
                    newData = data.clone();
                    // drop columns &gt; 3 from new
                    for (c = noColumns - 1; c &gt; 2; c -= 1) {
                        newData.removeColumn(c);
                    }

                    // build new 3. column
                    for (r = 0; r &lt; noRows; r += 1) {
                        newValue = &quot;&lt;div class=&#x27;sgvizler sgvizler-sMap&#x27;&gt;&quot;;
                        newValue += &quot;&lt;h1&gt;&quot; + data.getValue(r, 2) + &quot;&lt;/h1&gt;&quot;;
                        if (5 &lt; noColumns &amp;&amp; data.getValue(r, 5) !== null) {
                            newValue += &quot;&lt;div class=&#x27;img&#x27;&gt;&lt;img src=&#x27;&quot; + data.getValue(r, 5) + &quot;&#x27;/&gt;&lt;/div&gt;&quot;;
                        }
                        if (3 &lt; noColumns &amp;&amp; data.getValue(r, 3) !== null) {
                            newValue += &quot;&lt;p class=&#x27;text&#x27;&gt;&quot; + data.getValue(r, 3) + &quot;&lt;/p&gt;&quot;;
                        }
                        if (4 &lt; noColumns &amp;&amp; data.getValue(r, 4) !== null) {
                            newValue += &quot;&lt;p class=&#x27;link&#x27;&gt;&lt;a href=&#x27;&quot; + namespace.unprefixify(data.getValue(r, 4)) + &quot;&#x27;&gt;&quot; + data.getValue(r, 4) + &quot;&lt;/a&gt;&lt;/p&gt;&quot;;
                        }
                        newValue += &quot;&lt;/div&gt;&quot;;
                        newData.setCell(r, 2, newValue);
                    }
                } else { // do nothing.
                    newData = data;
                }

                chart = new google.visualization.Map(this.container);
                chart.draw(newData, opt);

                google.visualization.events.addListener(
                    chart,
                    &#x27;ready&#x27;,
                    function () { that.fireListener(&#x27;ready&#x27;); }
                );
            },
            {&#x27;google.visualization.Map&#x27;: &#x27;map&#x27; }
            );

        /**
         * Make a html list, either numbered (ol) or bullets
         * (ul). Each row becomes a list item.
         * 
         * Any number of columns in any format. Everything is
         * displayed as text.
         * 
         * @class sgvizler.visualization.List
         * @extends sgvizler.charts.Chart
         * @constructor
         * @param {Object} container The container element where the
         * chart will be drawn.
         * @since 0.3.0
         **/

        /** 
         * Available options:
         * 
         *  - &#x27;list&#x27;      :  &quot;ol&quot; / &quot;ul&quot;  (default: &quot;ul&quot;)
         *  - &#x27;cellSep&#x27;   :  string (can be html) to separate cells in row. (default: &#x27;, &#x27;)
         *  - &#x27;rowPrefix  :  string (can be html) to prefix each row with. (default: &#x27;&#x27;)
         *  - &#x27;rowPostfix :  string (can be html) to postfix each row with. (default: &#x27;&#x27;)
         * 
         * @method draw
         * @public
         * @param {google.visualization.DataTable} data
         * @param {Object} [chartOptions]
         * @since 0.3.0
         **/
        C.List = charts.add(modSC, &quot;List&quot;,
            function (data, chartOpt) {
                var c, noColumns = data.getNumberOfColumns(),
                    r, noRows = data.getNumberOfRows(),
                    opt = $.extend({ list: &#x27;ul&#x27;,
                                     cellSep: &#x27;, &#x27;,
                                     rowPrefix: &#x27;&#x27;,
                                     rowPostfix: &#x27;&#x27; },
                                   chartOpt),
                    list = &#x27;&lt;&#x27; + opt.list + &#x27;&gt;&#x27;;

                for (r = 0; r &lt; noRows; r += 1) {
                    list += &#x27;&lt;li&gt;&#x27; + opt.rowPrefix;
                    for (c = 0; c &lt; noColumns; c += 1) {
                        list += C.util.linkify2String(data.getValue(r, c));
                        if (c + 1 !== noColumns) { // Don&#x27;t add after last element in a row.
                            list += opt.cellSep;
                        }
                    }
                    list += opt.rowPostfix + &#x27;&lt;/li&gt;&#x27;;
                }
                list += &#x27;&lt;/&#x27; + opt.list + &#x27;&gt;&#x27;;

                $(this.container)
                    .empty()
                    .html(list);

                this.fireListener(&#x27;ready&#x27;);
            }
            );


        /** 
         * @class sgvizler.visualization.D3ForceGraph
         * @extends sgvizler.charts.Chart
         * @constructor
         * @param {Object} container The container element where the
         * chart will be drawn.
         * @beta
         */

        /** 
         * @method draw
         * @public
         * @param {google.visualization.DataTable} data
         * @param {Object} [chartOptions]
         * @since 0.5.0
         */
        /*global d3 */
        C.D3ForceGraph = charts.add(modSC, &#x27;D3ForceGraph&#x27;,
            function (data, chartOpt) {
                var r, noRows = data.getNumberOfRows(),
                    i, len,
                    noColumns = data.getNumberOfColumns(),

                    opt = $.extend({&#x27;maxnodesize&#x27;: 15, &#x27;minnodesize&#x27;: 2 }, chartOpt), // set defaults
                    colors = d3.scale.category20(),
                    w = chartOpt.width,
                    h = chartOpt.height,
                    isNumber = function (n) {  return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n); },

                    // build arrays of nodes and links.
                    nodes = [],
                    edges = [],
                    t_color = {},
                    t_size = {},
                    t_maxnodesize = 0,

                    source,
                    target,

                    nodesizeratio,
                    color,
                    size,

                    vis,
                    force,
                    link,
                    node,
                    ticks;

                C.util.loadCSS();

                for (r = 0; r &lt; noRows; r += 1) {
                    source = data.getValue(r, 0);
                    target = data.getValue(r, 1);
                    // nodes
                    if (source !== null &amp;&amp; $.inArray(source, nodes) === -1) {
                        nodes.push(source);
                        t_size[source] = (noColumns &gt; 2) ? Math.sqrt(data.getValue(r, 2)) : 0;
                        t_color[source] = (noColumns &gt; 3) ? data.getValue(r, 3) : 0;
                        if (t_size[source] &gt; t_maxnodesize) {
                            t_maxnodesize = t_size[source];
                        }
                    }
                    if (target !== null &amp;&amp; $.inArray(target, nodes) === -1) {
                        nodes.push(target);
                    }
                    // edges
                    if (source !== null &amp;&amp; target !== null) {
                        edges.push({&#x27;source&#x27;: $.inArray(source, nodes),
                                    &#x27;target&#x27;: $.inArray(target, nodes)
                                }
                            );
                    }
                }
                if (t_maxnodesize === 0) {
                    t_maxnodesize = 1;
                }
                nodesizeratio = opt.maxnodesize / t_maxnodesize;
                for (i = 0, len = nodes.length; i &lt; len; i += 1) {
                    color = t_color[nodes[i]] !== undefined ?
                            t_color[nodes[i]] :
                            1;
                    size = isNumber(t_size[nodes[i]]) ?
                            opt.minnodesize + t_size[nodes[i]] * nodesizeratio :
                            opt.minnodesize;

                    nodes[i] = {&#x27;name&#x27;: nodes[i], &#x27;color&#x27;: color, &#x27;size&#x27;: size };
                }

                $(this.container).empty();

                vis = d3.select(this.container)
                    .append(&quot;svg:svg&quot;)
                    .attr(&quot;width&quot;, w)
                    .attr(&quot;height&quot;, h)
                    .attr(&quot;pointer-events&quot;, &quot;all&quot;)
                    .append(&#x27;svg:g&#x27;)
                    .call(d3.behavior.zoom().on(&quot;zoom&quot;, function () {
                        vis.attr(&quot;transform&quot;, &quot;translate(&quot; + d3.event.translate + &quot;)&quot; +
                             &quot; scale(&quot; + d3.event.scale + &quot;)&quot;);
                    }))
                    .append(&#x27;svg:g&#x27;);

                vis.append(&#x27;svg:rect&#x27;)
                    .attr(&#x27;width&#x27;, w)
                    .attr(&#x27;height&#x27;, h)
                    .attr(&#x27;fill&#x27;, &#x27;white&#x27;);

                force = d3.layout.force()
                    .gravity(0.05)
                    .distance(100)
                    .charge(-100)
                    .nodes(nodes)
                    .links(edges)
                    .size([w, h])
                    .start();

                link = vis.selectAll(&quot;line.link&quot;)
                    .data(edges)
                    .enter().append(&quot;svg:line&quot;)
                    .attr(&quot;class&quot;, &quot;link&quot;)
                    //.style(&quot;stroke-width&quot;, function (d) { return Math.sqrt(d.value); })
                    .attr(&quot;x1&quot;, function (d) { return d.source.x; })
                    .attr(&quot;y1&quot;, function (d) { return d.source.y; })
                    .attr(&quot;x2&quot;, function (d) { return d.target.x; })
                    .attr(&quot;y2&quot;, function (d) { return d.target.y; });

                node = vis.selectAll(&quot;g.node&quot;)
                    .data(nodes)
                    .enter().append(&quot;svg:g&quot;)
                    .attr(&quot;class&quot;, &quot;node&quot;)
                    .call(force.drag);

                node.append(&quot;svg:circle&quot;)
                    .style(&quot;fill&quot;, function (d) { return colors(d.color); })
                    .attr(&quot;class&quot;, &quot;node&quot;)
                    .attr(&quot;r&quot;, function (d) { return d.size; });

                node.append(&quot;svg:title&quot;)
                    .text(function (d) { return d.name; });

                node.append(&quot;svg:text&quot;)
                    .attr(&quot;class&quot;, &quot;nodetext&quot;)
                    .attr(&quot;dx&quot;, 12)
                    .attr(&quot;dy&quot;, &quot;.35em&quot;)
                    .text(function (d) { return d.name; });

                ticks = 0;
                force.on(&quot;tick&quot;, function () {
                    ticks += 1;
                    if (ticks &gt; 250) {
                        force.stop();
                        force.charge(0)
                            .linkStrength(0)
                            .linkDistance(0)
                            .gravity(0)
                            .start();
                    }

                    link.attr(&quot;x1&quot;, function (d) { return d.source.x; })
                        .attr(&quot;y1&quot;, function (d) { return d.source.y; })
                        .attr(&quot;x2&quot;, function (d) { return d.target.x; })
                        .attr(&quot;y2&quot;, function (d) { return d.target.y; });

                    node.attr(&quot;transform&quot;, function (d) {
                        return &quot;translate(&quot; + d.x + &quot;,&quot; + d.y + &quot;)&quot;;
                    });
                });

                this.fireListener(&#x27;ready&#x27;);
            },
            { d3: &#x27;//cdnjs.cloudflare.com/ajax/libs/d3/2.10.0/d3.v2.min.js&#x27; }
            );

        /**
         * Utility functions for chart functions.
         *
         * .visualization
         * @class sgvizler.visualization.util
         * @static
         */

        C.util = (function () {
            var

                /**
                 * Converts a url into a prefixified link or a picture.
                 * @method linkify
                 * @private
                 * @param {String} url The url to linkify.
                 * @param {boolean} arraySyntax Flag if results should
                 * be rendered in array syntax (true), or as an HTML
                 * string (false).
                 * @param {String} width The width of the image
                 * @param {String} height The height of the image
                 * @return {String}
                 */
                linkify = function (url, arraySyntax, width, height) {
                    if (typeof(width) == &#x27;undefined&#x27;){
                        width=&#x27;100&#x27;;
                    }
                    if (typeof(height) == &#x27;undefined&#x27;){
                        height=&#x27;100&#x27;;
                    }
                    var prefixed = namespace.prefixify(url),
                        base = namespace.getBaseURL(),
                        href = url, // the hyperlink.
                        link,       // what to click.
                        result;   

                    // Is it linkable, or something else?
                    if (prefixed !== url) {
                        link = prefixed;
                    } else if (S.util.isURL(url)) {
                        link = url;
                    }

                    // If it is linkable, then HTML encode it as one.
                    if (link) {
                       
                            // Append base URL to front, if specified.
                            if (base) {
                                href = base + url;
                            }
                            // Returns a result according to the format used by
                            // sgvizler.util.createHTMLElement.
                            if (arraySyntax) {
                                result = [&#x27;a&#x27;, { href: href }, link];
                            } else { // straight html
                                result = &#x27;&lt;a href=&#x27; + href + &#x27;&gt;&#x27; + link + &#x27;&lt;/a&gt;&#x27;;
                            }
                        
                    } else { // If it is not a link, then just pass it through.
                        result = url;
                    } 
                    // Check if the link refers to a picture
                    if (/(jpeg|jpg|gif|png|JPG|PNG|JPEG|svg)$/.test(url)){
                        //Return a result in straight html
                        if ( arraySyntax == false) {
                             result = &#x27;&lt;img src=&#x27; + url + &#x27; alt= &quot;text&quot; style= &quot;width:&#x27; + width + &#x27;;height:&#x27; + height + &#x27;;&quot;&gt; &#x27;;
                        }
                    }
                    return result;
                },
                cssloaded = false;

            return {
                /**
                 * Converts a url into a &#x60;&lt;a href=&quot;&quot;&gt; or a &lt;img src=&quot;&quot;&gt;&#x60; element with the
                 * link prefixified.
                 * @method linkify2String
                 * @protected
                 * @param {String} url The url to linkify.
                 * @param {String} width The width of the image
                 * @param {String} height The height of the image
                 * @return {String}
                 */
                linkify2String: function (url,width,height) {
                    if (typeof(width) == &#x27;undefined&#x27;){
                        width=&#x27;100&#x27;;
                    }
                    if (typeof(height) == &#x27;undefined&#x27;){
                        height=&#x27;100&#x27;;
                    }
                    return linkify(url, false, width, height);
                    
                },
                /**
                 * Converts a url into an array on the format
                 * described in &#x60;sgvizler.util.createHTMLElement&#x60;.
                 * @method linkify2HTMLElemntArray
                 * @protected
                 * @param {String} url The url to linkify.
                 * @return {Array}
                 */
                linkify2HTMLElementArray: function (url) {
                    return linkify(url, true);
                },

                /**
                 * Loads the css file &#x60;sgvizler.charts.css&#x60;.
                 * @method loadCSS
                 * @protected
                 * @injects
                 */
                loadCSS: function () {
                    if (!cssloaded) {
                        $(&#x27;head&#x27;).append(&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;&#x27; + S.core.CHARTSCSS + &#x27;&quot; type=&quot;text/css&quot; /&gt;&#x27;);
                        cssloaded = true;
                    }
                },

                /**
                * Loads the Bootstrap necessary for Table_pict
                * @method loadBOOTSTRAP
                * @protected
                * @injects
                */
                loadBOOTSTRAP: function() {
                        $(&#x27;head&#x27;).append(&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&#x27;);
                        $(&#x27;head&#x27;).append(&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;/&gt;&#x27;);
                        $(&#x27;head&#x27;).append(&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css&quot; integrity=&quot;sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp&quot; crossorigin=&quot;anonymous&quot;/&gt;&#x27;); 
                }
            };
        }());

        return C;
    }());

    /** 
     * Contains functions for datatable manipulation.
     * 
     * @class sgvizler.datatable
     * @static
     */
    S.datatable = (function () {

        // Module dependencies:
        var namespace = S.namespace,
            datatables = S.datatables,

            DT = {}, // sgvizler.datatable

            modST = &quot;sgvizler.datatable&quot;;
        /**
         * This function is a modified version of
         * http://jsfiddle.net/asgallant/HkjDe/ A discussion is here
         * https://groups.google.com/forum/?fromgroups=#!topic/google-visualization-api/jl_5JpODmw8
         *
         * pivot gets in input a Google DataTable. Table must have 3
         * columns.  Pivoting the table will swap all the rows of the
         * first colum as columns for the new table and all the rows
         * of the second column as the rows of the new table. The
         * aggregate function is the sum.  So, borrowing data form the
         * discussion above:
         *
         *     Equipment‚ÄÉ  Location  Count‚ÄÉ
         *     e1          c1        6
         *     e2          c1        2
         *     e3          c1        1
         *     e4          c1        3
         *     e1          c2        7
         *     e2          c2        3
         *     e1          c3        8
         *     e2          c3        4
         *
         *         E1  E2  E3  E4
         *     C1  XX  xx  xx  xx
         *     C2  xx  xx   0  xx
         *     C3   0  xx  xx  xx
         *
         * @method pivot
         * @public
         * @param {google.visualization.DataTable} data
         * @return {google.visualization.DataTable}
         * @since 0.6.0
         */
        DT.pivot = datatables.add(modST, &quot;pivot&quot;, function (dataTable) {

            var columns = dataTable.getDistinctValues(0), // Get elements which will become columns.
                dataView = new google.visualization.DataView(dataTable),

            // Manually pivot the data table. First, we have to separate
            // out the &quot;equipment&quot; values into their own columns using a
            // DataView with calculated columns.

                cary = columns.map(function (item) {
                    return {
                        type: &#x27;number&#x27;,
                        label: item,
                        calc: function (dt, row) {
                            // return values only for the rows where first element === item
                            return (dt.getValue(row, 0) === item) ? dt.getValue(row, 2) : null;
                        }
                    };
                }),

            // Next, we group the view on the location column, which gets
            // us the pivoted data.
                rary = columns.map(function (item, index) {
                    return {
                        column: index + 1,
                        type: &#x27;number&#x27;,
                        label: item,
                        aggregation: google.visualization.data.sum
                    };
                });

            // Put 1 in front of everything.
            cary.unshift(1);

            dataView.setColumns(cary);

            return google.visualization.data.group(dataView, [0], rary);
        });


        /** 
         * Walks through all cells of columns with datatype string and
         * runs prefixify, which replaces namespace with its prefix.
         *
         * @method prefixify
         * @public
         * @param {google.visualization.DataTable} data
         * @return {google.visualization.DataTable}
         * @since 0.6.0
         */
        DT.prefixify = datatables.add(modST, &#x27;prefixify&#x27;, function (dataTable) {
            var c, clen = dataTable.getNumberOfColumns(),
                r, rlen = dataTable.getNumberOfRows();

            for (c = 0; c &lt; clen; c += 1) {
                if (dataTable.getColumnType(c) === &#x27;string&#x27;) {
                    for (r = 0; r &lt; rlen; r += 1) {
                        dataTable.setValue(r, c,
                            namespace.prefixify(dataTable.getValue(r, c))
                            );
                    }
                }
            }
            return dataTable;
        });


        return DT;
    }());

    //// OTHER SOURCE FILES ARE CONCATENATED IN ABOVE
    //// STARTING WITH start.js.part

    // Set some variables used in return statement.
    globalGetSet = S.util.getset;
    globalDefaultsQuery = S.defaults.query;
    globalDefaultsChart = S.defaults.chart;


    // Test if a thing names sgvizler already exists.
    if (window.sgvizler) {
        throw new Error(&quot;Javascript module &#x27;sgvizler&#x27; already exists.&quot;);
    }

    /**
     * The sgvizler javascript reveals properties (attributes) and methods
     * (functions) through the what in this documentation is known as the
     * class &#x60;sgvizler&#x60;. This is also why there is both a module and a
     * class called &#x60;sgvizler&#x60;. The other class which offers a public API
     * is the &#x60;sgvizler.Query&#x60; class. All other classes in the
     * documentation are private.
     *
     * Members which internally are &quot;public&quot;, i.e., available to other
     * classes within the sgvizler package, are marked
     * &#x60;@protected&#x60;. Members which are only available within its class are
     * marked &#x60;@private&#x60;.
     *
     * @class sgvizler
     * @static
     **/
    window.sgvizler = {


        //////////////////////////////////
        // The following properties and methods are documented where
        // they are written.

        VERSION: S.core.VERSION,
        HOMEPAGE: S.core.HOMEPAGE,

        chartsAdd: S.charts.add,
        datatablesAdd: S.datatables.add,

        registryChartFunctions: S.registry.chartFunctions,

        namespacePrefixesSPARQL: S.namespace.prefixesSPARQL,
        namespacePrefixify: S.namespace.prefixify,
        namespaceUnprefixify: S.namespace.unprefixify,

        containerDraw: S.container.draw,
        containerDrawAll: S.container.drawAll,

        formDraw: S.form.draw,
        formSubmit: S.form.submit,
        formReset: S.form.reset,

        Query: S.Query,

        visualization: S.visualization, // TODO: hide util?
        datatable: S.datatable,


        // getters, setters. cascade pattern.

        /**
         * Get the namespace for a prefix.
         * @method prefix
         * @public
         * @param {string} prefix
         * @return {string} The namespace recorded for the given prefix.
         * @since 0.6.0
         **/
        /**
         * Set the prefix for a namespace.
         * @method prefix
         * @public
         * @param {string} prefix
         * @param {string} namespace
         * @chainable
         * @since 0.6.0
         **/
        prefix: function (prefix, namespace) {
            if (namespace !== undefined) {
                S.namespace.set(prefix, namespace);
            }
            return (namespace !== undefined) ? this : S.namespace.get(prefix);
        },

        /**
         * Get Base URL.
         * @method defaultBaseURL
         * @public
         * @return {string} Returns an empty string if base URL is not set.
         * @since 0.6.0
         **/
        /**
         * Set Base URL. 
         * @method defaultBaseURL
         * @public
         * @param {string} url
         * @chainable
         * @since 0.6.0
         **/
        baseURL: function (url) {
            if (url !== undefined) {
                S.namespace.setBaseURL(url);
            }
            return (url !== undefined) ? this : S.namespace.getBaseURL() || &quot;&quot;;
        },

        /**
         * Get default query string.
         * @method defaultQuery
         * @public
         * @return {string}
         * @since 0.6.0
         **/
        /**
         * Set default query string.
         * @method defaultQuery
         * @public
         * @param {string} queryString
         * @chainable
         * @since 0.6.0
         **/
        defaultQuery: function (queryString) {
            return globalGetSet(&#x27;query&#x27;, queryString, globalDefaultsQuery, this);
        },

        /**
         * Get default list of FROMs set to be included in SPARQL query.
         * @method defaultFroms
         * @public
         * @return {Array} An array of strings.
         * @chainable
         * @since 0.6.0
         **/
        /**
         * Set default list of FROMs to be included in SPARQL query.
         * @method defaultFroms
         * @public
         * @param {Array} froms An array of strings.
         * @chainable
         * @since 0.6.0
         **/
        defaultFroms: function (froms) {
            var getset = globalGetSet(&#x27;froms&#x27;, froms, globalDefaultsQuery, this);
            if (getset !== this) {
                getset = getset.slice(0);
            }
            return getset;
        },

        /**
         * Get default endpoint URL.
         * @method defaultEndpointURL
         * @public
         * @return {string}
         * @since 0.6.0
         **/
        /**
         * Set default endpoint URL.
         * @method defaultEndpointURL
         * @public
         * @param {string} endpointURL
         * @chainable
         * @example
         *     sgvizler.defaultEndpointURL(&#x27;http://sparql.dbpedia.org&#x27;);
         *   sets the default endpoint to DBpedia&#x27;s.
         * @since 0.6.0
         **/
        defaultEndpointURL: function (endpointURL) {
            return globalGetSet(&#x27;endpoint&#x27;, endpointURL, globalDefaultsQuery, this);
        },

        /**
         * Get default endpoint output format.
         * @method defaultEndpointOutputFormat
         * @public
         * @return {string}
         * @since 0.6.0
         **/
        /**
         * Set default endpoint output format. Legal values are &#x60;&#x27;xml&#x27;&#x60;, &#x60;&#x27;json&#x27;&#x60;, &#x60;&#x27;jsonp&#x27;&#x60;.
         * @method defaultEndpointOutputFormat
         * @public
         * @param {string} format
         * @chainable
         * @since 0.6.0
         **/
        defaultEndpointOutputFormat: function (format) {
            return globalGetSet(&#x27;endpoint_output_format&#x27;, format, globalDefaultsQuery, this);
        },

        // TODO
        defaultEndpointResultsURLPart: function (value) {
            return globalGetSet(&#x27;endpoint_results_urlpart&#x27;, value, globalDefaultsQuery, this);
        },

        /**
         * Get URL to online SPARQL query validator.
         * @method defaultValidatorURL
         * @public
         * @return {string}
         * @since 0.6.0
         **/
        /**
         * Set URL to online SPARQL query validator. Appending a
         * SPARQL query to the end of this URL should give a page
         * which validates the given query.
         * @method defaultValidatorURL
         * @public
         * @param {string} url
         * @chainable
         * @since 0.6.0
         **/
        defaultValidatorURL: function (url) {
            return globalGetSet(&#x27;validator_url&#x27;, url, globalDefaultsQuery, this);
        },

        // TODO
        defaultLogContainer: function (value) {
            return globalGetSet(&#x27;logcontainer&#x27;, value, globalDefaultsQuery, this);
        },
        // TODO

        /**
         * These are the java ones, taken from [the
         * javadocs](http://docs.oracle.com/javase/1.4.2/docs/api/java/util/logging/Level.html):
         *
         * Permissible values are:
         *
         *   - SEVERE (highest value)
         *   - WARNING
         *   - INFO
         *   - CONFIG
         *   - FINE
         *   - FINER
         *   - FINEST (lowest value)
         * @method defaultLoglevel
         */
        defaultLogLevel: function (value) {
            return globalGetSet(&#x27;loglevel&#x27;, value, globalDefaultsQuery, this);
        },

        /**
         * Get the name of the default datatable preprocessing
         * function.
         * @method defaultDatatableFunction
         * @public
         * @return {string}
         * @since 0.6.0
         **/
        /**
         * Set the name of the default datatable preprocessing function. The
         * function should be available in the global object, or
         * registered with dependencies in Sgvizler&#x27;s registry;
         * see sgvizler.datatablesAdd()
         * @method defaultDatatableFunction
         * @public
         * @param {string} functionName
         * @chainable
         * @since 0.6.0
         **/
        defaultDatatableFunction: function (functionName) {
            return globalGetSet(&#x27;datatable&#x27;, functionName, globalDefaultsQuery, this);
        },

        /**
         * Get the name of the default chart function.
         * @method defaultChartFunction
         * @public
         * @return {string}
         * @since 0.6.0
         **/
        /**
         * Set the name of the default chart function. The
         * function should be availble in the global object, or
         * registered with dependencies in Sgvizler&#x27;s registry;
         * see sgvizler.chartsAdd()
         * @method defaultChartFunction
         * @public
         * @param {string} functionName
         * @chainable
         * @since 0.6.0
         **/
        defaultChartFunction: function (functionName) {
            return globalGetSet(&#x27;chart&#x27;, functionName, globalDefaultsQuery, this);
        },

        /**
         * Get the default height of chart containers.
         * @method defaultChartHeight
         * @public
         * @return {string}
         * @since 0.6.0
         **/
        /**
         * Set the default height of chart containers.
         * @method defaultChartHeight
         * @public
         * @param {number} height
         * @chainable
         * @since 0.6.0
         **/
        defaultChartHeight: function (height) {
            return globalGetSet(&#x27;height&#x27;, height, globalDefaultsChart, this);
        },

        /**
         * Get the default width of chart containers.
         * @method defaultChartWidth
         * @public
         * @return {string}
         * @since 0.6.0
         **/
        /**
         * Set the default width of chart containers.
         * @method defaultChartWidth
         * @public
         * @param {number} width
         * @chainable
         * @since 0.6.0
         **/
        defaultChartWidth: function (width) {
            return globalGetSet(&#x27;width&#x27;, width, globalDefaultsChart, this);
        },

        /**
         * TODO
         * @method defaultChartSpecificOption
         * @public
         * @chainable
         * @since 0.6.0
         **/
        defaultChartSpecificOption: function (chart, option, value) {
            S.defaults.setChartSpecificOption(chart, option, value);
            return this;
        }
    };

    jQuery.ajaxSetup(
        {
            cache: true,
            accepts: {
                xml:   &quot;application/sparql-results+xml&quot;,
                json:  &quot;application/sparql-results+json&quot;,
                jsonp: &quot;application/sparql-results+json&quot;
            }
        }
    );

}(window));

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
